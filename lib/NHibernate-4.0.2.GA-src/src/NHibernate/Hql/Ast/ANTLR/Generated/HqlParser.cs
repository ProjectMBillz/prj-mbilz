//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 Hql.g 2014-08-03 19:45:40

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using NHibernate.Hql.Ast.ANTLR.Tree;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  NHibernate.Hql.Ast.ANTLR 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class HqlParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AGGREGATE", "ALIAS", "ALL", "AND", "ANY", "AS", "ASCENDING", "AVG", "BAND", "BETWEEN", "BNOT", "BOR", "BOTH", "BXOR", "CASE", "CASE2", "CLASS", "CLOSE", "CLOSE_BRACKET", "COLON", "COMMA", "CONCAT", "CONSTANT", "CONSTRUCTOR", "COUNT", "DELETE", "DESCENDING", "DISTINCT", "DIV", "DOT", "ELEMENTS", "ELSE", "EMPTY", "END", "EQ", "ESCAPE", "ESCqs", "EXISTS", "EXPONENT", "EXPR_LIST", "FALSE", "FETCH", "FILTER_ENTITY", "FLOAT_SUFFIX", "FROM", "FULL", "GE", "GROUP", "GT", "HAVING", "HEX_DIGIT", "IDENT", "ID_LETTER", "ID_START_LETTER", "IN", "INDEX_OP", "INDICES", "INNER", "INSERT", "INTO", "IN_LIST", "IS", "IS_NOT_NULL", "IS_NULL", "JAVA_CONSTANT", "JOIN", "LE", "LEADING", "LEFT", "LIKE", "LITERAL_by", "LT", "MAX", "MEMBER", "METHOD_CALL", "MIN", "MINUS", "NE", "NEW", "NOT", "NOT_BETWEEN", "NOT_IN", "NOT_LIKE", "NULL", "NUM_DECIMAL", "NUM_DOUBLE", "NUM_FLOAT", "NUM_INT", "NUM_LONG", "OBJECT", "OF", "ON", "OPEN", "OPEN_BRACKET", "OR", "ORDER", "ORDER_ELEMENT", "OUTER", "PARAM", "PLUS", "PROPERTIES", "QUERY", "QUOTED_String", "RANGE", "RIGHT", "ROW_STAR", "SELECT", "SELECT_FROM", "SET", "SKIP", "SOME", "SQL_NE", "STAR", "SUM", "TAKE", "THEN", "TRAILING", "TRUE", "UNARY_MINUS", "UNARY_PLUS", "UNION", "UPDATE", "VECTOR_EXPR", "VERSIONED", "WEIRD_IDENT", "WHEN", "WHERE", "WITH", "WS", "'ascending'", "'descending'"
	};
	public const int EOF=-1;
	public const int AGGREGATE=4;
	public const int ALIAS=5;
	public const int ALL=6;
	public const int AND=7;
	public const int ANY=8;
	public const int AS=9;
	public const int ASCENDING=10;
	public const int AVG=11;
	public const int BAND=12;
	public const int BETWEEN=13;
	public const int BNOT=14;
	public const int BOR=15;
	public const int BOTH=16;
	public const int BXOR=17;
	public const int CASE=18;
	public const int CASE2=19;
	public const int CLASS=20;
	public const int CLOSE=21;
	public const int CLOSE_BRACKET=22;
	public const int COLON=23;
	public const int COMMA=24;
	public const int CONCAT=25;
	public const int CONSTANT=26;
	public const int CONSTRUCTOR=27;
	public const int COUNT=28;
	public const int DELETE=29;
	public const int DESCENDING=30;
	public const int DISTINCT=31;
	public const int DIV=32;
	public const int DOT=33;
	public const int ELEMENTS=34;
	public const int ELSE=35;
	public const int EMPTY=36;
	public const int END=37;
	public const int EQ=38;
	public const int ESCAPE=39;
	public const int ESCqs=40;
	public const int EXISTS=41;
	public const int EXPONENT=42;
	public const int EXPR_LIST=43;
	public const int FALSE=44;
	public const int FETCH=45;
	public const int FILTER_ENTITY=46;
	public const int FLOAT_SUFFIX=47;
	public const int FROM=48;
	public const int FULL=49;
	public const int GE=50;
	public const int GROUP=51;
	public const int GT=52;
	public const int HAVING=53;
	public const int HEX_DIGIT=54;
	public const int IDENT=55;
	public const int ID_LETTER=56;
	public const int ID_START_LETTER=57;
	public const int IN=58;
	public const int INDEX_OP=59;
	public const int INDICES=60;
	public const int INNER=61;
	public const int INSERT=62;
	public const int INTO=63;
	public const int IN_LIST=64;
	public const int IS=65;
	public const int IS_NOT_NULL=66;
	public const int IS_NULL=67;
	public const int JAVA_CONSTANT=68;
	public const int JOIN=69;
	public const int LE=70;
	public const int LEADING=71;
	public const int LEFT=72;
	public const int LIKE=73;
	public const int LITERAL_by=74;
	public const int LT=75;
	public const int MAX=76;
	public const int MEMBER=77;
	public const int METHOD_CALL=78;
	public const int MIN=79;
	public const int MINUS=80;
	public const int NE=81;
	public const int NEW=82;
	public const int NOT=83;
	public const int NOT_BETWEEN=84;
	public const int NOT_IN=85;
	public const int NOT_LIKE=86;
	public const int NULL=87;
	public const int NUM_DECIMAL=88;
	public const int NUM_DOUBLE=89;
	public const int NUM_FLOAT=90;
	public const int NUM_INT=91;
	public const int NUM_LONG=92;
	public const int OBJECT=93;
	public const int OF=94;
	public const int ON=95;
	public const int OPEN=96;
	public const int OPEN_BRACKET=97;
	public const int OR=98;
	public const int ORDER=99;
	public const int ORDER_ELEMENT=100;
	public const int OUTER=101;
	public const int PARAM=102;
	public const int PLUS=103;
	public const int PROPERTIES=104;
	public const int QUERY=105;
	public const int QUOTED_String=106;
	public const int RANGE=107;
	public const int RIGHT=108;
	public const int ROW_STAR=109;
	public const int SELECT=110;
	public const int SELECT_FROM=111;
	public const int SET=112;
	public const int SKIP=113;
	public const int SOME=114;
	public const int SQL_NE=115;
	public const int STAR=116;
	public const int SUM=117;
	public const int TAKE=118;
	public const int THEN=119;
	public const int TRAILING=120;
	public const int TRUE=121;
	public const int UNARY_MINUS=122;
	public const int UNARY_PLUS=123;
	public const int UNION=124;
	public const int UPDATE=125;
	public const int VECTOR_EXPR=126;
	public const int VERSIONED=127;
	public const int WEIRD_IDENT=128;
	public const int WHEN=129;
	public const int WHERE=130;
	public const int WITH=131;
	public const int WS=132;
	public const int T__133=133;
	public const int T__134=134;

	public HqlParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public HqlParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return HqlParser.tokenNames; } }
	public override string GrammarFileName { get { return "Hql.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// Hql.g:129:8: public statement : ( updateStatement | deleteStatement | selectStatement | insertStatement ) EOF !;
	[GrammarRule("statement")]
	public AstParserRuleReturnScope<IASTNode, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 1);
		TraceIn("statement", 1);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken EOF5 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> updateStatement1 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> deleteStatement2 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> selectStatement3 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> insertStatement4 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode EOF5_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(129, 1);
		try
		{
			// Hql.g:130:2: ( ( updateStatement | deleteStatement | selectStatement | insertStatement ) EOF !)
			DebugEnterAlt(1);
			// Hql.g:130:4: ( updateStatement | deleteStatement | selectStatement | insertStatement ) EOF !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(130, 4);
			// Hql.g:130:4: ( updateStatement | deleteStatement | selectStatement | insertStatement )
			int alt1=4;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case UPDATE:
				{
				alt1 = 1;
				}
				break;
			case DELETE:
				{
				alt1 = 2;
				}
				break;
			case EOF:
			case CLOSE:
			case FROM:
			case GROUP:
			case HAVING:
			case ORDER:
			case SELECT:
			case SKIP:
			case TAKE:
			case UNION:
			case WHERE:
				{
				alt1 = 3;
				}
				break;
			case INSERT:
				{
				alt1 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:130:6: updateStatement
				{
				DebugLocation(130, 6);
				PushFollow(Follow._updateStatement_in_statement613);
				updateStatement1=updateStatement();
				PopFollow();

				adaptor.AddChild(root_0, updateStatement1.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:130:24: deleteStatement
				{
				DebugLocation(130, 24);
				PushFollow(Follow._deleteStatement_in_statement617);
				deleteStatement2=deleteStatement();
				PopFollow();

				adaptor.AddChild(root_0, deleteStatement2.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:130:42: selectStatement
				{
				DebugLocation(130, 42);
				PushFollow(Follow._selectStatement_in_statement621);
				selectStatement3=selectStatement();
				PopFollow();

				adaptor.AddChild(root_0, selectStatement3.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:130:60: insertStatement
				{
				DebugLocation(130, 60);
				PushFollow(Follow._insertStatement_in_statement625);
				insertStatement4=insertStatement();
				PopFollow();

				adaptor.AddChild(root_0, insertStatement4.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(130, 81);
			EOF5=(IToken)Match(input,EOF,Follow._EOF_in_statement629); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 1);
			LeaveRule("statement", 1);
			LeaveRule_statement();
		}
		DebugLocation(131, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_updateStatement();
	partial void LeaveRule_updateStatement();
	// $ANTLR start "updateStatement"
	// Hql.g:133:1: updateStatement : UPDATE ^ ( VERSIONED )? optionalFromTokenFromClause setClause ( whereClause )? ;
	[GrammarRule("updateStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> updateStatement()
	{
		EnterRule_updateStatement();
		EnterRule("updateStatement", 2);
		TraceIn("updateStatement", 2);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken UPDATE6 = default(IToken);
		IToken VERSIONED7 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause8 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> setClause9 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> whereClause10 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode UPDATE6_tree = default(IASTNode);
		IASTNode VERSIONED7_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "updateStatement");
		DebugLocation(133, 1);
		try
		{
			// Hql.g:134:2: ( UPDATE ^ ( VERSIONED )? optionalFromTokenFromClause setClause ( whereClause )? )
			DebugEnterAlt(1);
			// Hql.g:134:4: UPDATE ^ ( VERSIONED )? optionalFromTokenFromClause setClause ( whereClause )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(134, 10);
			UPDATE6=(IToken)Match(input,UPDATE,Follow._UPDATE_in_updateStatement641); 
			UPDATE6_tree = (IASTNode)adaptor.Create(UPDATE6);
			root_0 = (IASTNode)adaptor.BecomeRoot(UPDATE6_tree, root_0);
			DebugLocation(134, 12);
			// Hql.g:134:12: ( VERSIONED )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==VERSIONED))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:134:13: VERSIONED
				{
				DebugLocation(134, 13);
				VERSIONED7=(IToken)Match(input,VERSIONED,Follow._VERSIONED_in_updateStatement645); 
				VERSIONED7_tree = (IASTNode)adaptor.Create(VERSIONED7);
				adaptor.AddChild(root_0, VERSIONED7_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(135, 3);
			PushFollow(Follow._optionalFromTokenFromClause_in_updateStatement651);
			optionalFromTokenFromClause8=optionalFromTokenFromClause();
			PopFollow();

			adaptor.AddChild(root_0, optionalFromTokenFromClause8.Tree);
			DebugLocation(136, 3);
			PushFollow(Follow._setClause_in_updateStatement655);
			setClause9=setClause();
			PopFollow();

			adaptor.AddChild(root_0, setClause9.Tree);
			DebugLocation(137, 3);
			// Hql.g:137:3: ( whereClause )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==WHERE))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:137:4: whereClause
				{
				DebugLocation(137, 4);
				PushFollow(Follow._whereClause_in_updateStatement660);
				whereClause10=whereClause();
				PopFollow();

				adaptor.AddChild(root_0, whereClause10.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("updateStatement", 2);
			LeaveRule("updateStatement", 2);
			LeaveRule_updateStatement();
		}
		DebugLocation(138, 1);
		} finally { DebugExitRule(GrammarFileName, "updateStatement"); }
		return retval;

	}
	// $ANTLR end "updateStatement"

	partial void EnterRule_setClause();
	partial void LeaveRule_setClause();
	// $ANTLR start "setClause"
	// Hql.g:140:1: setClause : ( SET ^ assignment ( COMMA ! assignment )* ) ;
	[GrammarRule("setClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> setClause()
	{
		EnterRule_setClause();
		EnterRule("setClause", 3);
		TraceIn("setClause", 3);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken SET11 = default(IToken);
		IToken COMMA13 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> assignment12 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> assignment14 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode SET11_tree = default(IASTNode);
		IASTNode COMMA13_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "setClause");
		DebugLocation(140, 1);
		try
		{
			// Hql.g:141:2: ( ( SET ^ assignment ( COMMA ! assignment )* ) )
			DebugEnterAlt(1);
			// Hql.g:141:4: ( SET ^ assignment ( COMMA ! assignment )* )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(141, 4);
			// Hql.g:141:4: ( SET ^ assignment ( COMMA ! assignment )* )
			DebugEnterAlt(1);
			// Hql.g:141:5: SET ^ assignment ( COMMA ! assignment )*
			{
			DebugLocation(141, 8);
			SET11=(IToken)Match(input,SET,Follow._SET_in_setClause674); 
			SET11_tree = (IASTNode)adaptor.Create(SET11);
			root_0 = (IASTNode)adaptor.BecomeRoot(SET11_tree, root_0);
			DebugLocation(141, 10);
			PushFollow(Follow._assignment_in_setClause677);
			assignment12=assignment();
			PopFollow();

			adaptor.AddChild(root_0, assignment12.Tree);
			DebugLocation(141, 21);
			// Hql.g:141:21: ( COMMA ! assignment )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==COMMA))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:141:22: COMMA ! assignment
					{
					DebugLocation(141, 27);
					COMMA13=(IToken)Match(input,COMMA,Follow._COMMA_in_setClause680); 
					DebugLocation(141, 29);
					PushFollow(Follow._assignment_in_setClause683);
					assignment14=assignment();
					PopFollow();

					adaptor.AddChild(root_0, assignment14.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("setClause", 3);
			LeaveRule("setClause", 3);
			LeaveRule_setClause();
		}
		DebugLocation(142, 1);
		} finally { DebugExitRule(GrammarFileName, "setClause"); }
		return retval;

	}
	// $ANTLR end "setClause"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();
	// $ANTLR start "assignment"
	// Hql.g:144:1: assignment : stateField EQ ^ newValue ;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<IASTNode, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 4);
		TraceIn("assignment", 4);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken EQ16 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> stateField15 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> newValue17 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode EQ16_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(144, 1);
		try
		{
			// Hql.g:145:2: ( stateField EQ ^ newValue )
			DebugEnterAlt(1);
			// Hql.g:145:4: stateField EQ ^ newValue
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(145, 4);
			PushFollow(Follow._stateField_in_assignment697);
			stateField15=stateField();
			PopFollow();

			adaptor.AddChild(root_0, stateField15.Tree);
			DebugLocation(145, 17);
			EQ16=(IToken)Match(input,EQ,Follow._EQ_in_assignment699); 
			EQ16_tree = (IASTNode)adaptor.Create(EQ16);
			root_0 = (IASTNode)adaptor.BecomeRoot(EQ16_tree, root_0);
			DebugLocation(145, 19);
			PushFollow(Follow._newValue_in_assignment702);
			newValue17=newValue();
			PopFollow();

			adaptor.AddChild(root_0, newValue17.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 4);
			LeaveRule("assignment", 4);
			LeaveRule_assignment();
		}
		DebugLocation(146, 1);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_stateField();
	partial void LeaveRule_stateField();
	// $ANTLR start "stateField"
	// Hql.g:150:1: stateField : path ;
	[GrammarRule("stateField")]
	private AstParserRuleReturnScope<IASTNode, IToken> stateField()
	{
		EnterRule_stateField();
		EnterRule("stateField", 5);
		TraceIn("stateField", 5);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> path18 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "stateField");
		DebugLocation(150, 1);
		try
		{
			// Hql.g:151:2: ( path )
			DebugEnterAlt(1);
			// Hql.g:151:4: path
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(151, 4);
			PushFollow(Follow._path_in_stateField715);
			path18=path();
			PopFollow();

			adaptor.AddChild(root_0, path18.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stateField", 5);
			LeaveRule("stateField", 5);
			LeaveRule_stateField();
		}
		DebugLocation(152, 1);
		} finally { DebugExitRule(GrammarFileName, "stateField"); }
		return retval;

	}
	// $ANTLR end "stateField"

	partial void EnterRule_newValue();
	partial void LeaveRule_newValue();
	// $ANTLR start "newValue"
	// Hql.g:156:1: newValue : concatenation ;
	[GrammarRule("newValue")]
	private AstParserRuleReturnScope<IASTNode, IToken> newValue()
	{
		EnterRule_newValue();
		EnterRule("newValue", 6);
		TraceIn("newValue", 6);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> concatenation19 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "newValue");
		DebugLocation(156, 1);
		try
		{
			// Hql.g:157:2: ( concatenation )
			DebugEnterAlt(1);
			// Hql.g:157:4: concatenation
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(157, 4);
			PushFollow(Follow._concatenation_in_newValue728);
			concatenation19=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation19.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newValue", 6);
			LeaveRule("newValue", 6);
			LeaveRule_newValue();
		}
		DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "newValue"); }
		return retval;

	}
	// $ANTLR end "newValue"

	partial void EnterRule_deleteStatement();
	partial void LeaveRule_deleteStatement();
	// $ANTLR start "deleteStatement"
	// Hql.g:160:1: deleteStatement : DELETE ^ ( optionalFromTokenFromClause ) ( whereClause )? ;
	[GrammarRule("deleteStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> deleteStatement()
	{
		EnterRule_deleteStatement();
		EnterRule("deleteStatement", 7);
		TraceIn("deleteStatement", 7);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken DELETE20 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause21 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> whereClause22 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode DELETE20_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "deleteStatement");
		DebugLocation(160, 1);
		try
		{
			// Hql.g:161:2: ( DELETE ^ ( optionalFromTokenFromClause ) ( whereClause )? )
			DebugEnterAlt(1);
			// Hql.g:161:4: DELETE ^ ( optionalFromTokenFromClause ) ( whereClause )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(161, 10);
			DELETE20=(IToken)Match(input,DELETE,Follow._DELETE_in_deleteStatement739); 
			DELETE20_tree = (IASTNode)adaptor.Create(DELETE20);
			root_0 = (IASTNode)adaptor.BecomeRoot(DELETE20_tree, root_0);
			DebugLocation(162, 3);
			// Hql.g:162:3: ( optionalFromTokenFromClause )
			DebugEnterAlt(1);
			// Hql.g:162:4: optionalFromTokenFromClause
			{
			DebugLocation(162, 4);
			PushFollow(Follow._optionalFromTokenFromClause_in_deleteStatement745);
			optionalFromTokenFromClause21=optionalFromTokenFromClause();
			PopFollow();

			adaptor.AddChild(root_0, optionalFromTokenFromClause21.Tree);

			}

			DebugLocation(163, 3);
			// Hql.g:163:3: ( whereClause )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==WHERE))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:163:4: whereClause
				{
				DebugLocation(163, 4);
				PushFollow(Follow._whereClause_in_deleteStatement751);
				whereClause22=whereClause();
				PopFollow();

				adaptor.AddChild(root_0, whereClause22.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("deleteStatement", 7);
			LeaveRule("deleteStatement", 7);
			LeaveRule_deleteStatement();
		}
		DebugLocation(164, 1);
		} finally { DebugExitRule(GrammarFileName, "deleteStatement"); }
		return retval;

	}
	// $ANTLR end "deleteStatement"

	partial void EnterRule_optionalFromTokenFromClause();
	partial void LeaveRule_optionalFromTokenFromClause();
	// $ANTLR start "optionalFromTokenFromClause"
	// Hql.g:168:1: optionalFromTokenFromClause : optionalFromTokenFromClause2 path ( asAlias )? -> ^( FROM ^( RANGE path ( asAlias )? ) ) ;
	[GrammarRule("optionalFromTokenFromClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause()
	{
		EnterRule_optionalFromTokenFromClause();
		EnterRule("optionalFromTokenFromClause", 8);
		TraceIn("optionalFromTokenFromClause", 8);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause223 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path24 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> asAlias25 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_optionalFromTokenFromClause2=new RewriteRuleSubtreeStream(adaptor,"rule optionalFromTokenFromClause2");
		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		RewriteRuleSubtreeStream stream_asAlias=new RewriteRuleSubtreeStream(adaptor,"rule asAlias");
		try { DebugEnterRule(GrammarFileName, "optionalFromTokenFromClause");
		DebugLocation(168, 1);
		try
		{
			// Hql.g:169:2: ( optionalFromTokenFromClause2 path ( asAlias )? -> ^( FROM ^( RANGE path ( asAlias )? ) ) )
			DebugEnterAlt(1);
			// Hql.g:169:4: optionalFromTokenFromClause2 path ( asAlias )?
			{
			DebugLocation(169, 4);
			PushFollow(Follow._optionalFromTokenFromClause2_in_optionalFromTokenFromClause766);
			optionalFromTokenFromClause223=optionalFromTokenFromClause2();
			PopFollow();

			stream_optionalFromTokenFromClause2.Add(optionalFromTokenFromClause223.Tree);
			DebugLocation(169, 33);
			PushFollow(Follow._path_in_optionalFromTokenFromClause768);
			path24=path();
			PopFollow();

			stream_path.Add(path24.Tree);
			DebugLocation(169, 38);
			// Hql.g:169:38: ( asAlias )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==AS||LA6_1==IDENT))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:169:39: asAlias
				{
				DebugLocation(169, 39);
				PushFollow(Follow._asAlias_in_optionalFromTokenFromClause771);
				asAlias25=asAlias();
				PopFollow();

				stream_asAlias.Add(asAlias25.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: path, asAlias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 170:3: -> ^( FROM ^( RANGE path ( asAlias )? ) )
			{
				DebugLocation(170, 6);
				// Hql.g:170:6: ^( FROM ^( RANGE path ( asAlias )? ) )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(170, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(FROM, "FROM"), root_1);

				DebugLocation(170, 13);
				// Hql.g:170:13: ^( RANGE path ( asAlias )? )
				{
				IASTNode root_2 = (IASTNode)adaptor.Nil();
				DebugLocation(170, 15);
				root_2 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "RANGE"), root_2);

				DebugLocation(170, 21);
				adaptor.AddChild(root_2, stream_path.NextTree());
				DebugLocation(170, 26);
				// Hql.g:170:26: ( asAlias )?
				if (stream_asAlias.HasNext)
				{
					DebugLocation(170, 26);
					adaptor.AddChild(root_2, stream_asAlias.NextTree());

				}
				stream_asAlias.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("optionalFromTokenFromClause", 8);
			LeaveRule("optionalFromTokenFromClause", 8);
			LeaveRule_optionalFromTokenFromClause();
		}
		DebugLocation(171, 1);
		} finally { DebugExitRule(GrammarFileName, "optionalFromTokenFromClause"); }
		return retval;

	}
	// $ANTLR end "optionalFromTokenFromClause"

	partial void EnterRule_optionalFromTokenFromClause2();
	partial void LeaveRule_optionalFromTokenFromClause2();
	// $ANTLR start "optionalFromTokenFromClause2"
	// Hql.g:173:1: optionalFromTokenFromClause2 : ( FROM )? ;
	[GrammarRule("optionalFromTokenFromClause2")]
	private AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause2()
	{
		EnterRule_optionalFromTokenFromClause2();
		EnterRule("optionalFromTokenFromClause2", 9);
		TraceIn("optionalFromTokenFromClause2", 9);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken FROM26 = default(IToken);

		IASTNode FROM26_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "optionalFromTokenFromClause2");
		DebugLocation(173, 1);
		try
		{
			// Hql.g:174:2: ( ( FROM )? )
			DebugEnterAlt(1);
			// Hql.g:174:4: ( FROM )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(174, 4);
			// Hql.g:174:4: ( FROM )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==FROM))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:174:4: FROM
				{
				DebugLocation(174, 4);
				FROM26=(IToken)Match(input,FROM,Follow._FROM_in_optionalFromTokenFromClause2802); 
				FROM26_tree = (IASTNode)adaptor.Create(FROM26);
				adaptor.AddChild(root_0, FROM26_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("optionalFromTokenFromClause2", 9);
			LeaveRule("optionalFromTokenFromClause2", 9);
			LeaveRule_optionalFromTokenFromClause2();
		}
		DebugLocation(175, 1);
		} finally { DebugExitRule(GrammarFileName, "optionalFromTokenFromClause2"); }
		return retval;

	}
	// $ANTLR end "optionalFromTokenFromClause2"

	partial void EnterRule_selectStatement();
	partial void LeaveRule_selectStatement();
	// $ANTLR start "selectStatement"
	// Hql.g:177:1: selectStatement : q= queryRule -> ^( QUERY[\"query\"] $q) ;
	[GrammarRule("selectStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectStatement()
	{
		EnterRule_selectStatement();
		EnterRule("selectStatement", 10);
		TraceIn("selectStatement", 10);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> q = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_queryRule=new RewriteRuleSubtreeStream(adaptor,"rule queryRule");
		try { DebugEnterRule(GrammarFileName, "selectStatement");
		DebugLocation(177, 1);
		try
		{
			// Hql.g:178:2: (q= queryRule -> ^( QUERY[\"query\"] $q) )
			DebugEnterAlt(1);
			// Hql.g:178:4: q= queryRule
			{
			DebugLocation(178, 5);
			PushFollow(Follow._queryRule_in_selectStatement816);
			q=queryRule();
			PopFollow();

			stream_queryRule.Add(q.Tree);


			{
			// AST REWRITE
			// elements: q
			// token labels: 
			// rule labels: q, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_q=new RewriteRuleSubtreeStream(adaptor,"rule q",q!=null?q.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 179:2: -> ^( QUERY[\"query\"] $q)
			{
				DebugLocation(179, 5);
				// Hql.g:179:5: ^( QUERY[\"query\"] $q)
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(179, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(QUERY, "query"), root_1);

				DebugLocation(179, 23);
				adaptor.AddChild(root_1, stream_q.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectStatement", 10);
			LeaveRule("selectStatement", 10);
			LeaveRule_selectStatement();
		}
		DebugLocation(180, 1);
		} finally { DebugExitRule(GrammarFileName, "selectStatement"); }
		return retval;

	}
	// $ANTLR end "selectStatement"

	partial void EnterRule_insertStatement();
	partial void LeaveRule_insertStatement();
	// $ANTLR start "insertStatement"
	// Hql.g:182:1: insertStatement : INSERT ^ intoClause selectStatement ;
	[GrammarRule("insertStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> insertStatement()
	{
		EnterRule_insertStatement();
		EnterRule("insertStatement", 11);
		TraceIn("insertStatement", 11);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken INSERT27 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> intoClause28 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> selectStatement29 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode INSERT27_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "insertStatement");
		DebugLocation(182, 1);
		try
		{
			// Hql.g:186:2: ( INSERT ^ intoClause selectStatement )
			DebugEnterAlt(1);
			// Hql.g:186:4: INSERT ^ intoClause selectStatement
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(186, 10);
			INSERT27=(IToken)Match(input,INSERT,Follow._INSERT_in_insertStatement845); 
			INSERT27_tree = (IASTNode)adaptor.Create(INSERT27);
			root_0 = (IASTNode)adaptor.BecomeRoot(INSERT27_tree, root_0);
			DebugLocation(186, 12);
			PushFollow(Follow._intoClause_in_insertStatement848);
			intoClause28=intoClause();
			PopFollow();

			adaptor.AddChild(root_0, intoClause28.Tree);
			DebugLocation(186, 23);
			PushFollow(Follow._selectStatement_in_insertStatement850);
			selectStatement29=selectStatement();
			PopFollow();

			adaptor.AddChild(root_0, selectStatement29.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("insertStatement", 11);
			LeaveRule("insertStatement", 11);
			LeaveRule_insertStatement();
		}
		DebugLocation(187, 1);
		} finally { DebugExitRule(GrammarFileName, "insertStatement"); }
		return retval;

	}
	// $ANTLR end "insertStatement"

	partial void EnterRule_intoClause();
	partial void LeaveRule_intoClause();
	// $ANTLR start "intoClause"
	// Hql.g:189:1: intoClause : INTO ^ path insertablePropertySpec ;
	[GrammarRule("intoClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> intoClause()
	{
		EnterRule_intoClause();
		EnterRule("intoClause", 12);
		TraceIn("intoClause", 12);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken INTO30 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path31 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> insertablePropertySpec32 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode INTO30_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "intoClause");
		DebugLocation(189, 1);
		try
		{
			// Hql.g:190:2: ( INTO ^ path insertablePropertySpec )
			DebugEnterAlt(1);
			// Hql.g:190:4: INTO ^ path insertablePropertySpec
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(190, 8);
			INTO30=(IToken)Match(input,INTO,Follow._INTO_in_intoClause861); 
			INTO30_tree = (IASTNode)adaptor.Create(INTO30);
			root_0 = (IASTNode)adaptor.BecomeRoot(INTO30_tree, root_0);
			DebugLocation(190, 10);
			PushFollow(Follow._path_in_intoClause864);
			path31=path();
			PopFollow();

			adaptor.AddChild(root_0, path31.Tree);
			DebugLocation(190, 15);
			 WeakKeywords(); 
			DebugLocation(190, 35);
			PushFollow(Follow._insertablePropertySpec_in_intoClause868);
			insertablePropertySpec32=insertablePropertySpec();
			PopFollow();

			adaptor.AddChild(root_0, insertablePropertySpec32.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("intoClause", 12);
			LeaveRule("intoClause", 12);
			LeaveRule_intoClause();
		}
		DebugLocation(191, 1);
		} finally { DebugExitRule(GrammarFileName, "intoClause"); }
		return retval;

	}
	// $ANTLR end "intoClause"

	partial void EnterRule_insertablePropertySpec();
	partial void LeaveRule_insertablePropertySpec();
	// $ANTLR start "insertablePropertySpec"
	// Hql.g:193:1: insertablePropertySpec : OPEN primaryExpression ( COMMA primaryExpression )* CLOSE -> ^( RANGE[\"column-spec\"] ( primaryExpression )* ) ;
	[GrammarRule("insertablePropertySpec")]
	private AstParserRuleReturnScope<IASTNode, IToken> insertablePropertySpec()
	{
		EnterRule_insertablePropertySpec();
		EnterRule("insertablePropertySpec", 13);
		TraceIn("insertablePropertySpec", 13);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken OPEN33 = default(IToken);
		IToken COMMA35 = default(IToken);
		IToken CLOSE37 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> primaryExpression34 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> primaryExpression36 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode OPEN33_tree = default(IASTNode);
		IASTNode COMMA35_tree = default(IASTNode);
		IASTNode CLOSE37_tree = default(IASTNode);
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
		try { DebugEnterRule(GrammarFileName, "insertablePropertySpec");
		DebugLocation(193, 1);
		try
		{
			// Hql.g:194:2: ( OPEN primaryExpression ( COMMA primaryExpression )* CLOSE -> ^( RANGE[\"column-spec\"] ( primaryExpression )* ) )
			DebugEnterAlt(1);
			// Hql.g:194:4: OPEN primaryExpression ( COMMA primaryExpression )* CLOSE
			{
			DebugLocation(194, 4);
			OPEN33=(IToken)Match(input,OPEN,Follow._OPEN_in_insertablePropertySpec879);  
			stream_OPEN.Add(OPEN33);

			DebugLocation(194, 9);
			PushFollow(Follow._primaryExpression_in_insertablePropertySpec881);
			primaryExpression34=primaryExpression();
			PopFollow();

			stream_primaryExpression.Add(primaryExpression34.Tree);
			DebugLocation(194, 27);
			// Hql.g:194:27: ( COMMA primaryExpression )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==COMMA))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:194:29: COMMA primaryExpression
					{
					DebugLocation(194, 29);
					COMMA35=(IToken)Match(input,COMMA,Follow._COMMA_in_insertablePropertySpec885);  
					stream_COMMA.Add(COMMA35);

					DebugLocation(194, 35);
					PushFollow(Follow._primaryExpression_in_insertablePropertySpec887);
					primaryExpression36=primaryExpression();
					PopFollow();

					stream_primaryExpression.Add(primaryExpression36.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(194, 56);
			CLOSE37=(IToken)Match(input,CLOSE,Follow._CLOSE_in_insertablePropertySpec892);  
			stream_CLOSE.Add(CLOSE37);



			{
			// AST REWRITE
			// elements: primaryExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 195:3: -> ^( RANGE[\"column-spec\"] ( primaryExpression )* )
			{
				DebugLocation(195, 6);
				// Hql.g:195:6: ^( RANGE[\"column-spec\"] ( primaryExpression )* )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(195, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "column-spec"), root_1);

				DebugLocation(195, 29);
				// Hql.g:195:29: ( primaryExpression )*
				while ( stream_primaryExpression.HasNext )
				{
					DebugLocation(195, 29);
					adaptor.AddChild(root_1, stream_primaryExpression.NextTree());

				}
				stream_primaryExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("insertablePropertySpec", 13);
			LeaveRule("insertablePropertySpec", 13);
			LeaveRule_insertablePropertySpec();
		}
		DebugLocation(196, 1);
		} finally { DebugExitRule(GrammarFileName, "insertablePropertySpec"); }
		return retval;

	}
	// $ANTLR end "insertablePropertySpec"

	partial void EnterRule_queryRule();
	partial void LeaveRule_queryRule();
	// $ANTLR start "queryRule"
	// Hql.g:201:1: queryRule : selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )? ;
	[GrammarRule("queryRule")]
	private AstParserRuleReturnScope<IASTNode, IToken> queryRule()
	{
		EnterRule_queryRule();
		EnterRule("queryRule", 14);
		TraceIn("queryRule", 14);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> selectFrom38 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> whereClause39 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> groupByClause40 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> havingClause41 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> orderByClause42 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> skipClause43 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> takeClause44 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "queryRule");
		DebugLocation(201, 2);
		try
		{
			// Hql.g:202:2: ( selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )? )
			DebugEnterAlt(1);
			// Hql.g:202:4: selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(202, 4);
			PushFollow(Follow._selectFrom_in_queryRule918);
			selectFrom38=selectFrom();
			PopFollow();

			adaptor.AddChild(root_0, selectFrom38.Tree);
			DebugLocation(203, 3);
			// Hql.g:203:3: ( whereClause )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==WHERE))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:203:4: whereClause
				{
				DebugLocation(203, 4);
				PushFollow(Follow._whereClause_in_queryRule923);
				whereClause39=whereClause();
				PopFollow();

				adaptor.AddChild(root_0, whereClause39.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(204, 3);
			// Hql.g:204:3: ( groupByClause )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==GROUP))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:204:4: groupByClause
				{
				DebugLocation(204, 4);
				PushFollow(Follow._groupByClause_in_queryRule930);
				groupByClause40=groupByClause();
				PopFollow();

				adaptor.AddChild(root_0, groupByClause40.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(205, 3);
			// Hql.g:205:3: ( havingClause )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==HAVING))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:205:4: havingClause
				{
				DebugLocation(205, 4);
				PushFollow(Follow._havingClause_in_queryRule937);
				havingClause41=havingClause();
				PopFollow();

				adaptor.AddChild(root_0, havingClause41.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(206, 3);
			// Hql.g:206:3: ( orderByClause )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1==ORDER))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:206:4: orderByClause
				{
				DebugLocation(206, 4);
				PushFollow(Follow._orderByClause_in_queryRule944);
				orderByClause42=orderByClause();
				PopFollow();

				adaptor.AddChild(root_0, orderByClause42.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(12); }

			DebugLocation(207, 3);
			// Hql.g:207:3: ( skipClause )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==SKIP))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:207:4: skipClause
				{
				DebugLocation(207, 4);
				PushFollow(Follow._skipClause_in_queryRule951);
				skipClause43=skipClause();
				PopFollow();

				adaptor.AddChild(root_0, skipClause43.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(208, 3);
			// Hql.g:208:3: ( takeClause )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==TAKE))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:208:4: takeClause
				{
				DebugLocation(208, 4);
				PushFollow(Follow._takeClause_in_queryRule958);
				takeClause44=takeClause();
				PopFollow();

				adaptor.AddChild(root_0, takeClause44.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("queryRule", 14);
			LeaveRule("queryRule", 14);
			LeaveRule_queryRule();
		}
		DebugLocation(209, 2);
		} finally { DebugExitRule(GrammarFileName, "queryRule"); }
		return retval;

	}
	// $ANTLR end "queryRule"

	partial void EnterRule_selectFrom();
	partial void LeaveRule_selectFrom();
	// $ANTLR start "selectFrom"
	// Hql.g:211:1: selectFrom : (s= selectClause )? (f= fromClause )? -> {$f.tree == null && filter}? ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? ) -> ^( SELECT_FROM ( fromClause )? ( selectClause )? ) ;
	[GrammarRule("selectFrom")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectFrom()
	{
		EnterRule_selectFrom();
		EnterRule("selectFrom", 15);
		TraceIn("selectFrom", 15);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> s = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> f = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_selectClause=new RewriteRuleSubtreeStream(adaptor,"rule selectClause");
		RewriteRuleSubtreeStream stream_fromClause=new RewriteRuleSubtreeStream(adaptor,"rule fromClause");
		try { DebugEnterRule(GrammarFileName, "selectFrom");
		DebugLocation(211, 1);
		try
		{
			// Hql.g:212:2: ( (s= selectClause )? (f= fromClause )? -> {$f.tree == null && filter}? ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? ) -> ^( SELECT_FROM ( fromClause )? ( selectClause )? ) )
			DebugEnterAlt(1);
			// Hql.g:212:5: (s= selectClause )? (f= fromClause )?
			{
			DebugLocation(212, 5);
			// Hql.g:212:5: (s= selectClause )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==SELECT))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:212:6: s= selectClause
				{
				DebugLocation(212, 7);
				PushFollow(Follow._selectClause_in_selectFrom976);
				s=selectClause();
				PopFollow();

				stream_selectClause.Add(s.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(212, 23);
			// Hql.g:212:23: (f= fromClause )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==FROM))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:212:24: f= fromClause
				{
				DebugLocation(212, 25);
				PushFollow(Follow._fromClause_in_selectFrom983);
				f=fromClause();
				PopFollow();

				stream_fromClause.Add(f.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(213, 3);

						if ((f!=null?((IASTNode)f.Tree):default(IASTNode)) == null && !filter) 
							throw new RecognitionException("FROM expected (non-filter queries must contain a FROM clause)");
					


			{
			// AST REWRITE
			// elements: selectClause, fromClause, selectClause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 217:3: -> {$f.tree == null && filter}? ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? )
			if ((f!=null?((IASTNode)f.Tree):default(IASTNode)) == null && filter)
			{
				DebugLocation(217, 35);
				// Hql.g:217:35: ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(217, 37);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(SELECT_FROM, "SELECT_FROM"), root_1);

				DebugLocation(217, 49);
				adaptor.AddChild(root_1, (IASTNode)adaptor.Create(FROM, "{filter-implied FROM}"));
				DebugLocation(217, 79);
				// Hql.g:217:79: ( selectClause )?
				if (stream_selectClause.HasNext)
				{
					DebugLocation(217, 79);
					adaptor.AddChild(root_1, stream_selectClause.NextTree());

				}
				stream_selectClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 218:3: -> ^( SELECT_FROM ( fromClause )? ( selectClause )? )
			{
				DebugLocation(218, 6);
				// Hql.g:218:6: ^( SELECT_FROM ( fromClause )? ( selectClause )? )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(218, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(SELECT_FROM, "SELECT_FROM"), root_1);

				DebugLocation(218, 20);
				// Hql.g:218:20: ( fromClause )?
				if (stream_fromClause.HasNext)
				{
					DebugLocation(218, 20);
					adaptor.AddChild(root_1, stream_fromClause.NextTree());

				}
				stream_fromClause.Reset();
				DebugLocation(218, 32);
				// Hql.g:218:32: ( selectClause )?
				if (stream_selectClause.HasNext)
				{
					DebugLocation(218, 32);
					adaptor.AddChild(root_1, stream_selectClause.NextTree());

				}
				stream_selectClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectFrom", 15);
			LeaveRule("selectFrom", 15);
			LeaveRule_selectFrom();
		}
		DebugLocation(219, 1);
		} finally { DebugExitRule(GrammarFileName, "selectFrom"); }
		return retval;

	}
	// $ANTLR end "selectFrom"

	partial void EnterRule_selectClause();
	partial void LeaveRule_selectClause();
	// $ANTLR start "selectClause"
	// Hql.g:222:1: selectClause : SELECT ^ ( DISTINCT )? ( selectedPropertiesList | newExpression | selectObject ) ;
	[GrammarRule("selectClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectClause()
	{
		EnterRule_selectClause();
		EnterRule("selectClause", 16);
		TraceIn("selectClause", 16);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken SELECT45 = default(IToken);
		IToken DISTINCT46 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> selectedPropertiesList47 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> newExpression48 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> selectObject49 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode SELECT45_tree = default(IASTNode);
		IASTNode DISTINCT46_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "selectClause");
		DebugLocation(222, 1);
		try
		{
			// Hql.g:223:2: ( SELECT ^ ( DISTINCT )? ( selectedPropertiesList | newExpression | selectObject ) )
			DebugEnterAlt(1);
			// Hql.g:223:4: SELECT ^ ( DISTINCT )? ( selectedPropertiesList | newExpression | selectObject )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(223, 10);
			SELECT45=(IToken)Match(input,SELECT,Follow._SELECT_in_selectClause1032); 
			SELECT45_tree = (IASTNode)adaptor.Create(SELECT45);
			root_0 = (IASTNode)adaptor.BecomeRoot(SELECT45_tree, root_0);
			DebugLocation(224, 3);
			 WeakKeywords(); 
			DebugLocation(225, 3);
			// Hql.g:225:3: ( DISTINCT )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==DISTINCT))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:225:4: DISTINCT
				{
				DebugLocation(225, 4);
				DISTINCT46=(IToken)Match(input,DISTINCT,Follow._DISTINCT_in_selectClause1044); 
				DISTINCT46_tree = (IASTNode)adaptor.Create(DISTINCT46);
				adaptor.AddChild(root_0, DISTINCT46_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(225, 15);
			// Hql.g:225:15: ( selectedPropertiesList | newExpression | selectObject )
			int alt18=3;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			switch (input.LA(1))
			{
			case ALL:
			case ANY:
			case AVG:
			case BNOT:
			case CASE:
			case COLON:
			case COUNT:
			case ELEMENTS:
			case EMPTY:
			case EXISTS:
			case FALSE:
			case IDENT:
			case INDICES:
			case MAX:
			case MIN:
			case MINUS:
			case NOT:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case OPEN:
			case PARAM:
			case PLUS:
			case QUOTED_String:
			case SOME:
			case SUM:
			case TRUE:
				{
				alt18 = 1;
				}
				break;
			case NEW:
				{
				alt18 = 2;
				}
				break;
			case OBJECT:
				{
				alt18 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:225:17: selectedPropertiesList
				{
				DebugLocation(225, 17);
				PushFollow(Follow._selectedPropertiesList_in_selectClause1050);
				selectedPropertiesList47=selectedPropertiesList();
				PopFollow();

				adaptor.AddChild(root_0, selectedPropertiesList47.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:225:42: newExpression
				{
				DebugLocation(225, 42);
				PushFollow(Follow._newExpression_in_selectClause1054);
				newExpression48=newExpression();
				PopFollow();

				adaptor.AddChild(root_0, newExpression48.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:225:58: selectObject
				{
				DebugLocation(225, 58);
				PushFollow(Follow._selectObject_in_selectClause1058);
				selectObject49=selectObject();
				PopFollow();

				adaptor.AddChild(root_0, selectObject49.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectClause", 16);
			LeaveRule("selectClause", 16);
			LeaveRule_selectClause();
		}
		DebugLocation(226, 1);
		} finally { DebugExitRule(GrammarFileName, "selectClause"); }
		return retval;

	}
	// $ANTLR end "selectClause"

	partial void EnterRule_newExpression();
	partial void LeaveRule_newExpression();
	// $ANTLR start "newExpression"
	// Hql.g:228:1: newExpression : ( NEW path ) op= OPEN selectedPropertiesList CLOSE -> ^( CONSTRUCTOR[$op] path selectedPropertiesList ) ;
	[GrammarRule("newExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> newExpression()
	{
		EnterRule_newExpression();
		EnterRule("newExpression", 17);
		TraceIn("newExpression", 17);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken op = default(IToken);
		IToken NEW50 = default(IToken);
		IToken CLOSE53 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path51 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> selectedPropertiesList52 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode op_tree = default(IASTNode);
		IASTNode NEW50_tree = default(IASTNode);
		IASTNode CLOSE53_tree = default(IASTNode);
		RewriteRuleITokenStream stream_NEW=new RewriteRuleITokenStream(adaptor,"token NEW");
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		RewriteRuleSubtreeStream stream_selectedPropertiesList=new RewriteRuleSubtreeStream(adaptor,"rule selectedPropertiesList");
		try { DebugEnterRule(GrammarFileName, "newExpression");
		DebugLocation(228, 1);
		try
		{
			// Hql.g:229:2: ( ( NEW path ) op= OPEN selectedPropertiesList CLOSE -> ^( CONSTRUCTOR[$op] path selectedPropertiesList ) )
			DebugEnterAlt(1);
			// Hql.g:229:4: ( NEW path ) op= OPEN selectedPropertiesList CLOSE
			{
			DebugLocation(229, 4);
			// Hql.g:229:4: ( NEW path )
			DebugEnterAlt(1);
			// Hql.g:229:5: NEW path
			{
			DebugLocation(229, 5);
			NEW50=(IToken)Match(input,NEW,Follow._NEW_in_newExpression1072);  
			stream_NEW.Add(NEW50);

			DebugLocation(229, 9);
			PushFollow(Follow._path_in_newExpression1074);
			path51=path();
			PopFollow();

			stream_path.Add(path51.Tree);

			}

			DebugLocation(229, 17);
			op=(IToken)Match(input,OPEN,Follow._OPEN_in_newExpression1079);  
			stream_OPEN.Add(op);

			DebugLocation(229, 23);
			PushFollow(Follow._selectedPropertiesList_in_newExpression1081);
			selectedPropertiesList52=selectedPropertiesList();
			PopFollow();

			stream_selectedPropertiesList.Add(selectedPropertiesList52.Tree);
			DebugLocation(229, 46);
			CLOSE53=(IToken)Match(input,CLOSE,Follow._CLOSE_in_newExpression1083);  
			stream_CLOSE.Add(CLOSE53);



			{
			// AST REWRITE
			// elements: path, selectedPropertiesList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 230:3: -> ^( CONSTRUCTOR[$op] path selectedPropertiesList )
			{
				DebugLocation(230, 6);
				// Hql.g:230:6: ^( CONSTRUCTOR[$op] path selectedPropertiesList )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(230, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(CONSTRUCTOR, op), root_1);

				DebugLocation(230, 25);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(230, 30);
				adaptor.AddChild(root_1, stream_selectedPropertiesList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newExpression", 17);
			LeaveRule("newExpression", 17);
			LeaveRule_newExpression();
		}
		DebugLocation(231, 1);
		} finally { DebugExitRule(GrammarFileName, "newExpression"); }
		return retval;

	}
	// $ANTLR end "newExpression"

	partial void EnterRule_selectObject();
	partial void LeaveRule_selectObject();
	// $ANTLR start "selectObject"
	// Hql.g:233:1: selectObject : OBJECT ^ OPEN ! identifier CLOSE !;
	[GrammarRule("selectObject")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectObject()
	{
		EnterRule_selectObject();
		EnterRule("selectObject", 18);
		TraceIn("selectObject", 18);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken OBJECT54 = default(IToken);
		IToken OPEN55 = default(IToken);
		IToken CLOSE57 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identifier56 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode OBJECT54_tree = default(IASTNode);
		IASTNode OPEN55_tree = default(IASTNode);
		IASTNode CLOSE57_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "selectObject");
		DebugLocation(233, 3);
		try
		{
			// Hql.g:234:4: ( OBJECT ^ OPEN ! identifier CLOSE !)
			DebugEnterAlt(1);
			// Hql.g:234:6: OBJECT ^ OPEN ! identifier CLOSE !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(234, 12);
			OBJECT54=(IToken)Match(input,OBJECT,Follow._OBJECT_in_selectObject1109); 
			OBJECT54_tree = (IASTNode)adaptor.Create(OBJECT54);
			root_0 = (IASTNode)adaptor.BecomeRoot(OBJECT54_tree, root_0);
			DebugLocation(234, 18);
			OPEN55=(IToken)Match(input,OPEN,Follow._OPEN_in_selectObject1112); 
			DebugLocation(234, 20);
			PushFollow(Follow._identifier_in_selectObject1115);
			identifier56=identifier();
			PopFollow();

			adaptor.AddChild(root_0, identifier56.Tree);
			DebugLocation(234, 36);
			CLOSE57=(IToken)Match(input,CLOSE,Follow._CLOSE_in_selectObject1117); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectObject", 18);
			LeaveRule("selectObject", 18);
			LeaveRule_selectObject();
		}
		DebugLocation(235, 3);
		} finally { DebugExitRule(GrammarFileName, "selectObject"); }
		return retval;

	}
	// $ANTLR end "selectObject"

	partial void EnterRule_fromClause();
	partial void LeaveRule_fromClause();
	// $ANTLR start "fromClause"
	// Hql.g:241:1: fromClause : FROM ^ fromRange ( fromJoin | COMMA ! fromRange )* ;
	[GrammarRule("fromClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromClause()
	{
		EnterRule_fromClause();
		EnterRule("fromClause", 19);
		TraceIn("fromClause", 19);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken FROM58 = default(IToken);
		IToken COMMA61 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> fromRange59 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> fromJoin60 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> fromRange62 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode FROM58_tree = default(IASTNode);
		IASTNode COMMA61_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "fromClause");
		DebugLocation(241, 1);
		try
		{
			// Hql.g:242:2: ( FROM ^ fromRange ( fromJoin | COMMA ! fromRange )* )
			DebugEnterAlt(1);
			// Hql.g:242:4: FROM ^ fromRange ( fromJoin | COMMA ! fromRange )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(242, 8);
			FROM58=(IToken)Match(input,FROM,Follow._FROM_in_fromClause1135); 
			FROM58_tree = (IASTNode)adaptor.Create(FROM58);
			root_0 = (IASTNode)adaptor.BecomeRoot(FROM58_tree, root_0);
			DebugLocation(242, 10);
			 WeakKeywords(); 
			DebugLocation(242, 30);
			PushFollow(Follow._fromRange_in_fromClause1140);
			fromRange59=fromRange();
			PopFollow();

			adaptor.AddChild(root_0, fromRange59.Tree);
			DebugLocation(242, 40);
			// Hql.g:242:40: ( fromJoin | COMMA ! fromRange )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=3;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==FULL||LA19_1==INNER||LA19_1==JOIN||LA19_1==LEFT||LA19_1==RIGHT))
				{
					alt19 = 1;
				}
				else if ((LA19_1==COMMA))
				{
					alt19 = 2;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:242:42: fromJoin
					{
					DebugLocation(242, 42);
					PushFollow(Follow._fromJoin_in_fromClause1144);
					fromJoin60=fromJoin();
					PopFollow();

					adaptor.AddChild(root_0, fromJoin60.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:242:53: COMMA ! fromRange
					{
					DebugLocation(242, 58);
					COMMA61=(IToken)Match(input,COMMA,Follow._COMMA_in_fromClause1148); 
					DebugLocation(242, 60);
					 WeakKeywords(); 
					DebugLocation(242, 80);
					PushFollow(Follow._fromRange_in_fromClause1153);
					fromRange62=fromRange();
					PopFollow();

					adaptor.AddChild(root_0, fromRange62.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromClause", 19);
			LeaveRule("fromClause", 19);
			LeaveRule_fromClause();
		}
		DebugLocation(243, 1);
		} finally { DebugExitRule(GrammarFileName, "fromClause"); }
		return retval;

	}
	// $ANTLR end "fromClause"

	partial void EnterRule_fromJoin();
	partial void LeaveRule_fromJoin();
	// $ANTLR start "fromJoin"
	// Hql.g:245:1: fromJoin : ( ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )? | ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? ELEMENTS ! OPEN ! path CLOSE ! ( asAlias )? ( propertyFetch )? ( withClause )? );
	[GrammarRule("fromJoin")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromJoin()
	{
		EnterRule_fromJoin();
		EnterRule("fromJoin", 20);
		TraceIn("fromJoin", 20);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken set63 = default(IToken);
		IToken OUTER64 = default(IToken);
		IToken FULL65 = default(IToken);
		IToken INNER66 = default(IToken);
		IToken JOIN67 = default(IToken);
		IToken FETCH68 = default(IToken);
		IToken set73 = default(IToken);
		IToken OUTER74 = default(IToken);
		IToken FULL75 = default(IToken);
		IToken INNER76 = default(IToken);
		IToken JOIN77 = default(IToken);
		IToken FETCH78 = default(IToken);
		IToken ELEMENTS79 = default(IToken);
		IToken OPEN80 = default(IToken);
		IToken CLOSE82 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path69 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> asAlias70 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> propertyFetch71 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> withClause72 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path81 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> asAlias83 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> propertyFetch84 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> withClause85 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode set63_tree = default(IASTNode);
		IASTNode OUTER64_tree = default(IASTNode);
		IASTNode FULL65_tree = default(IASTNode);
		IASTNode INNER66_tree = default(IASTNode);
		IASTNode JOIN67_tree = default(IASTNode);
		IASTNode FETCH68_tree = default(IASTNode);
		IASTNode set73_tree = default(IASTNode);
		IASTNode OUTER74_tree = default(IASTNode);
		IASTNode FULL75_tree = default(IASTNode);
		IASTNode INNER76_tree = default(IASTNode);
		IASTNode JOIN77_tree = default(IASTNode);
		IASTNode FETCH78_tree = default(IASTNode);
		IASTNode ELEMENTS79_tree = default(IASTNode);
		IASTNode OPEN80_tree = default(IASTNode);
		IASTNode CLOSE82_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "fromJoin");
		DebugLocation(245, 1);
		try
		{
			// Hql.g:246:2: ( ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )? | ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? ELEMENTS ! OPEN ! path CLOSE ! ( asAlias )? ( propertyFetch )? ( withClause )? )
			int alt32=2;
			try { DebugEnterDecision(32, false);
			switch (input.LA(1))
			{
			case LEFT:
			case RIGHT:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==OUTER))
				{
					int LA32_3 = input.LA(3);

					if ((LA32_3==JOIN))
					{
						switch (input.LA(4))
						{
						case FETCH:
							{
							int LA32_5 = input.LA(5);

							if ((LA32_5==IDENT))
							{
								alt32 = 1;
							}
							else if ((LA32_5==ELEMENTS))
							{
								alt32 = 2;
							}
							else
							{
								NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case IDENT:
							{
							alt32 = 1;
							}
							break;
						case ELEMENTS:
							{
							alt32 = 2;
							}
							break;
						default:
							{
								NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 32, 5, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA32_2==JOIN))
				{
					switch (input.LA(3))
					{
					case FETCH:
						{
						int LA32_4 = input.LA(4);

						if ((LA32_4==IDENT))
						{
							alt32 = 1;
						}
						else if ((LA32_4==ELEMENTS))
						{
							alt32 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case IDENT:
						{
						alt32 = 1;
						}
						break;
					case ELEMENTS:
						{
						alt32 = 2;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case FULL:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==JOIN))
				{
					switch (input.LA(3))
					{
					case FETCH:
						{
						int LA32_4 = input.LA(4);

						if ((LA32_4==IDENT))
						{
							alt32 = 1;
						}
						else if ((LA32_4==ELEMENTS))
						{
							alt32 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case IDENT:
						{
						alt32 = 1;
						}
						break;
					case ELEMENTS:
						{
						alt32 = 2;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INNER:
				{
				int LA32_2 = input.LA(2);

				if ((LA32_2==JOIN))
				{
					switch (input.LA(3))
					{
					case FETCH:
						{
						int LA32_4 = input.LA(4);

						if ((LA32_4==IDENT))
						{
							alt32 = 1;
						}
						else if ((LA32_4==ELEMENTS))
						{
							alt32 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case IDENT:
						{
						alt32 = 1;
						}
						break;
					case ELEMENTS:
						{
						alt32 = 2;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case JOIN:
				{
				switch (input.LA(2))
				{
				case FETCH:
					{
					int LA32_3 = input.LA(3);

					if ((LA32_3==IDENT))
					{
						alt32 = 1;
					}
					else if ((LA32_3==ELEMENTS))
					{
						alt32 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 32, 6, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case IDENT:
					{
					alt32 = 1;
					}
					break;
				case ELEMENTS:
					{
					alt32 = 2;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 32, 4, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:246:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(246, 4);
				// Hql.g:246:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )?
				int alt21=4;
				try { DebugEnterSubRule(21);
				try { DebugEnterDecision(21, false);
				switch (input.LA(1))
				{
				case LEFT:
				case RIGHT:
					{
					alt21 = 1;
					}
					break;
				case FULL:
					{
					alt21 = 2;
					}
					break;
				case INNER:
					{
					alt21 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:246:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					{
					DebugLocation(246, 6);
					// Hql.g:246:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					DebugEnterAlt(1);
					// Hql.g:246:8: ( LEFT | RIGHT ) ( OUTER )?
					{
					DebugLocation(246, 8);

					set63=(IToken)input.LT(1);
					if (input.LA(1)==LEFT||input.LA(1)==RIGHT)
					{
						input.Consume();
						adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set63));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(246, 25);
					// Hql.g:246:25: ( OUTER )?
					int alt20=2;
					try { DebugEnterSubRule(20);
					try { DebugEnterDecision(20, false);
					int LA20_1 = input.LA(1);

					if ((LA20_1==OUTER))
					{
						alt20 = 1;
					}
					} finally { DebugExitDecision(20); }
					switch (alt20)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:246:26: OUTER
						{
						DebugLocation(246, 26);
						OUTER64=(IToken)Match(input,OUTER,Follow._OUTER_in_fromJoin1182); 
						OUTER64_tree = (IASTNode)adaptor.Create(OUTER64);
						adaptor.AddChild(root_0, OUTER64_tree);

						}
						break;

					}
					} finally { DebugExitSubRule(20); }


					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:246:38: FULL
					{
					DebugLocation(246, 38);
					FULL65=(IToken)Match(input,FULL,Follow._FULL_in_fromJoin1190); 
					FULL65_tree = (IASTNode)adaptor.Create(FULL65);
					adaptor.AddChild(root_0, FULL65_tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:246:45: INNER
					{
					DebugLocation(246, 45);
					INNER66=(IToken)Match(input,INNER,Follow._INNER_in_fromJoin1194); 
					INNER66_tree = (IASTNode)adaptor.Create(INNER66);
					adaptor.AddChild(root_0, INNER66_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(21); }

				DebugLocation(246, 58);
				JOIN67=(IToken)Match(input,JOIN,Follow._JOIN_in_fromJoin1199); 
				JOIN67_tree = (IASTNode)adaptor.Create(JOIN67);
				root_0 = (IASTNode)adaptor.BecomeRoot(JOIN67_tree, root_0);
				DebugLocation(246, 60);
				// Hql.g:246:60: ( FETCH )?
				int alt22=2;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==FETCH))
				{
					alt22 = 1;
				}
				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:246:61: FETCH
					{
					DebugLocation(246, 61);
					FETCH68=(IToken)Match(input,FETCH,Follow._FETCH_in_fromJoin1203); 
					FETCH68_tree = (IASTNode)adaptor.Create(FETCH68);
					adaptor.AddChild(root_0, FETCH68_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(22); }

				DebugLocation(246, 69);
				PushFollow(Follow._path_in_fromJoin1207);
				path69=path();
				PopFollow();

				adaptor.AddChild(root_0, path69.Tree);
				DebugLocation(246, 74);
				// Hql.g:246:74: ( asAlias )?
				int alt23=2;
				try { DebugEnterSubRule(23);
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if ((LA23_1==AS||LA23_1==IDENT))
				{
					alt23 = 1;
				}
				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:246:75: asAlias
					{
					DebugLocation(246, 75);
					PushFollow(Follow._asAlias_in_fromJoin1210);
					asAlias70=asAlias();
					PopFollow();

					adaptor.AddChild(root_0, asAlias70.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(23); }

				DebugLocation(246, 85);
				// Hql.g:246:85: ( propertyFetch )?
				int alt24=2;
				try { DebugEnterSubRule(24);
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==FETCH))
				{
					alt24 = 1;
				}
				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:246:86: propertyFetch
					{
					DebugLocation(246, 86);
					PushFollow(Follow._propertyFetch_in_fromJoin1215);
					propertyFetch71=propertyFetch();
					PopFollow();

					adaptor.AddChild(root_0, propertyFetch71.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(24); }

				DebugLocation(246, 102);
				// Hql.g:246:102: ( withClause )?
				int alt25=2;
				try { DebugEnterSubRule(25);
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if ((LA25_1==WITH))
				{
					alt25 = 1;
				}
				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:246:103: withClause
					{
					DebugLocation(246, 103);
					PushFollow(Follow._withClause_in_fromJoin1220);
					withClause72=withClause();
					PopFollow();

					adaptor.AddChild(root_0, withClause72.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(25); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:247:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? ELEMENTS ! OPEN ! path CLOSE ! ( asAlias )? ( propertyFetch )? ( withClause )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(247, 4);
				// Hql.g:247:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )?
				int alt27=4;
				try { DebugEnterSubRule(27);
				try { DebugEnterDecision(27, false);
				switch (input.LA(1))
				{
				case LEFT:
				case RIGHT:
					{
					alt27 = 1;
					}
					break;
				case FULL:
					{
					alt27 = 2;
					}
					break;
				case INNER:
					{
					alt27 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:247:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					{
					DebugLocation(247, 6);
					// Hql.g:247:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					DebugEnterAlt(1);
					// Hql.g:247:8: ( LEFT | RIGHT ) ( OUTER )?
					{
					DebugLocation(247, 8);

					set73=(IToken)input.LT(1);
					if (input.LA(1)==LEFT||input.LA(1)==RIGHT)
					{
						input.Consume();
						adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set73));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(247, 25);
					// Hql.g:247:25: ( OUTER )?
					int alt26=2;
					try { DebugEnterSubRule(26);
					try { DebugEnterDecision(26, false);
					int LA26_1 = input.LA(1);

					if ((LA26_1==OUTER))
					{
						alt26 = 1;
					}
					} finally { DebugExitDecision(26); }
					switch (alt26)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:247:26: OUTER
						{
						DebugLocation(247, 26);
						OUTER74=(IToken)Match(input,OUTER,Follow._OUTER_in_fromJoin1242); 
						OUTER74_tree = (IASTNode)adaptor.Create(OUTER74);
						adaptor.AddChild(root_0, OUTER74_tree);

						}
						break;

					}
					} finally { DebugExitSubRule(26); }


					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:247:38: FULL
					{
					DebugLocation(247, 38);
					FULL75=(IToken)Match(input,FULL,Follow._FULL_in_fromJoin1250); 
					FULL75_tree = (IASTNode)adaptor.Create(FULL75);
					adaptor.AddChild(root_0, FULL75_tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:247:45: INNER
					{
					DebugLocation(247, 45);
					INNER76=(IToken)Match(input,INNER,Follow._INNER_in_fromJoin1254); 
					INNER76_tree = (IASTNode)adaptor.Create(INNER76);
					adaptor.AddChild(root_0, INNER76_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(27); }

				DebugLocation(247, 58);
				JOIN77=(IToken)Match(input,JOIN,Follow._JOIN_in_fromJoin1259); 
				JOIN77_tree = (IASTNode)adaptor.Create(JOIN77);
				root_0 = (IASTNode)adaptor.BecomeRoot(JOIN77_tree, root_0);
				DebugLocation(247, 60);
				// Hql.g:247:60: ( FETCH )?
				int alt28=2;
				try { DebugEnterSubRule(28);
				try { DebugEnterDecision(28, false);
				int LA28_1 = input.LA(1);

				if ((LA28_1==FETCH))
				{
					alt28 = 1;
				}
				} finally { DebugExitDecision(28); }
				switch (alt28)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:247:61: FETCH
					{
					DebugLocation(247, 61);
					FETCH78=(IToken)Match(input,FETCH,Follow._FETCH_in_fromJoin1263); 
					FETCH78_tree = (IASTNode)adaptor.Create(FETCH78);
					adaptor.AddChild(root_0, FETCH78_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(28); }

				DebugLocation(247, 77);
				ELEMENTS79=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_fromJoin1267); 
				DebugLocation(247, 83);
				OPEN80=(IToken)Match(input,OPEN,Follow._OPEN_in_fromJoin1270); 
				DebugLocation(247, 85);
				PushFollow(Follow._path_in_fromJoin1273);
				path81=path();
				PopFollow();

				adaptor.AddChild(root_0, path81.Tree);
				DebugLocation(247, 95);
				CLOSE82=(IToken)Match(input,CLOSE,Follow._CLOSE_in_fromJoin1275); 
				DebugLocation(247, 97);
				// Hql.g:247:97: ( asAlias )?
				int alt29=2;
				try { DebugEnterSubRule(29);
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1==AS||LA29_1==IDENT))
				{
					alt29 = 1;
				}
				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:247:98: asAlias
					{
					DebugLocation(247, 98);
					PushFollow(Follow._asAlias_in_fromJoin1279);
					asAlias83=asAlias();
					PopFollow();

					adaptor.AddChild(root_0, asAlias83.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(29); }

				DebugLocation(247, 108);
				// Hql.g:247:108: ( propertyFetch )?
				int alt30=2;
				try { DebugEnterSubRule(30);
				try { DebugEnterDecision(30, false);
				int LA30_1 = input.LA(1);

				if ((LA30_1==FETCH))
				{
					alt30 = 1;
				}
				} finally { DebugExitDecision(30); }
				switch (alt30)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:247:109: propertyFetch
					{
					DebugLocation(247, 109);
					PushFollow(Follow._propertyFetch_in_fromJoin1284);
					propertyFetch84=propertyFetch();
					PopFollow();

					adaptor.AddChild(root_0, propertyFetch84.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(30); }

				DebugLocation(247, 125);
				// Hql.g:247:125: ( withClause )?
				int alt31=2;
				try { DebugEnterSubRule(31);
				try { DebugEnterDecision(31, false);
				int LA31_1 = input.LA(1);

				if ((LA31_1==WITH))
				{
					alt31 = 1;
				}
				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:247:126: withClause
					{
					DebugLocation(247, 126);
					PushFollow(Follow._withClause_in_fromJoin1289);
					withClause85=withClause();
					PopFollow();

					adaptor.AddChild(root_0, withClause85.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(31); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromJoin", 20);
			LeaveRule("fromJoin", 20);
			LeaveRule_fromJoin();
		}
		DebugLocation(248, 1);
		} finally { DebugExitRule(GrammarFileName, "fromJoin"); }
		return retval;

	}
	// $ANTLR end "fromJoin"

	partial void EnterRule_withClause();
	partial void LeaveRule_withClause();
	// $ANTLR start "withClause"
	// Hql.g:250:1: withClause : WITH ^ logicalExpression ;
	[GrammarRule("withClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> withClause()
	{
		EnterRule_withClause();
		EnterRule("withClause", 21);
		TraceIn("withClause", 21);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken WITH86 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> logicalExpression87 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode WITH86_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "withClause");
		DebugLocation(250, 1);
		try
		{
			// Hql.g:251:2: ( WITH ^ logicalExpression )
			DebugEnterAlt(1);
			// Hql.g:251:4: WITH ^ logicalExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(251, 8);
			WITH86=(IToken)Match(input,WITH,Follow._WITH_in_withClause1302); 
			WITH86_tree = (IASTNode)adaptor.Create(WITH86);
			root_0 = (IASTNode)adaptor.BecomeRoot(WITH86_tree, root_0);
			DebugLocation(251, 10);
			PushFollow(Follow._logicalExpression_in_withClause1305);
			logicalExpression87=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression87.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("withClause", 21);
			LeaveRule("withClause", 21);
			LeaveRule_withClause();
		}
		DebugLocation(252, 1);
		} finally { DebugExitRule(GrammarFileName, "withClause"); }
		return retval;

	}
	// $ANTLR end "withClause"

	partial void EnterRule_fromRange();
	partial void LeaveRule_fromRange();
	// $ANTLR start "fromRange"
	// Hql.g:254:1: fromRange : ( fromClassOrOuterQueryPath | inClassDeclaration | inCollectionDeclaration | inCollectionElementsDeclaration );
	[GrammarRule("fromRange")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromRange()
	{
		EnterRule_fromRange();
		EnterRule("fromRange", 22);
		TraceIn("fromRange", 22);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> fromClassOrOuterQueryPath88 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> inClassDeclaration89 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> inCollectionDeclaration90 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> inCollectionElementsDeclaration91 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "fromRange");
		DebugLocation(254, 1);
		try
		{
			// Hql.g:255:2: ( fromClassOrOuterQueryPath | inClassDeclaration | inCollectionDeclaration | inCollectionElementsDeclaration )
			int alt33=4;
			try { DebugEnterDecision(33, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				int LA33_2 = input.LA(2);

				if ((LA33_2==EOF||LA33_2==AS||LA33_2==CLOSE||LA33_2==COMMA||LA33_2==DOT||LA33_2==FETCH||LA33_2==FULL||LA33_2==GROUP||LA33_2==HAVING||LA33_2==IDENT||LA33_2==INNER||LA33_2==JOIN||LA33_2==LEFT||LA33_2==ORDER||LA33_2==RIGHT||LA33_2==SKIP||LA33_2==TAKE||LA33_2==UNION||LA33_2==WHERE))
				{
					alt33 = 1;
				}
				else if ((LA33_2==IN))
				{
					int LA33_3 = input.LA(3);

					if ((LA33_3==ELEMENTS))
					{
						alt33 = 4;
					}
					else if ((LA33_3==CLASS||LA33_3==IDENT))
					{
						alt33 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 33, 5, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 33, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IN:
				{
				alt33 = 3;
				}
				break;
			case ELEMENTS:
				{
				alt33 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 33, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:255:4: fromClassOrOuterQueryPath
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(255, 4);
				PushFollow(Follow._fromClassOrOuterQueryPath_in_fromRange1316);
				fromClassOrOuterQueryPath88=fromClassOrOuterQueryPath();
				PopFollow();

				adaptor.AddChild(root_0, fromClassOrOuterQueryPath88.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:256:4: inClassDeclaration
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(256, 4);
				PushFollow(Follow._inClassDeclaration_in_fromRange1321);
				inClassDeclaration89=inClassDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, inClassDeclaration89.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:257:4: inCollectionDeclaration
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(257, 4);
				PushFollow(Follow._inCollectionDeclaration_in_fromRange1326);
				inCollectionDeclaration90=inCollectionDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, inCollectionDeclaration90.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:258:4: inCollectionElementsDeclaration
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(258, 4);
				PushFollow(Follow._inCollectionElementsDeclaration_in_fromRange1331);
				inCollectionElementsDeclaration91=inCollectionElementsDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, inCollectionElementsDeclaration91.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromRange", 22);
			LeaveRule("fromRange", 22);
			LeaveRule_fromRange();
		}
		DebugLocation(259, 1);
		} finally { DebugExitRule(GrammarFileName, "fromRange"); }
		return retval;

	}
	// $ANTLR end "fromRange"

	partial void EnterRule_fromClassOrOuterQueryPath();
	partial void LeaveRule_fromClassOrOuterQueryPath();
	// $ANTLR start "fromClassOrOuterQueryPath"
	// Hql.g:261:1: fromClassOrOuterQueryPath : path ( asAlias )? ( propertyFetch )? -> ^( RANGE path ( asAlias )? ( propertyFetch )? ) ;
	[GrammarRule("fromClassOrOuterQueryPath")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromClassOrOuterQueryPath()
	{
		EnterRule_fromClassOrOuterQueryPath();
		EnterRule("fromClassOrOuterQueryPath", 23);
		TraceIn("fromClassOrOuterQueryPath", 23);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> path92 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> asAlias93 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> propertyFetch94 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		RewriteRuleSubtreeStream stream_asAlias=new RewriteRuleSubtreeStream(adaptor,"rule asAlias");
		RewriteRuleSubtreeStream stream_propertyFetch=new RewriteRuleSubtreeStream(adaptor,"rule propertyFetch");
		try { DebugEnterRule(GrammarFileName, "fromClassOrOuterQueryPath");
		DebugLocation(261, 1);
		try
		{
			// Hql.g:262:2: ( path ( asAlias )? ( propertyFetch )? -> ^( RANGE path ( asAlias )? ( propertyFetch )? ) )
			DebugEnterAlt(1);
			// Hql.g:262:4: path ( asAlias )? ( propertyFetch )?
			{
			DebugLocation(262, 4);
			PushFollow(Follow._path_in_fromClassOrOuterQueryPath1343);
			path92=path();
			PopFollow();

			stream_path.Add(path92.Tree);
			DebugLocation(262, 9);
			 WeakKeywords(); 
			DebugLocation(262, 29);
			// Hql.g:262:29: ( asAlias )?
			int alt34=2;
			try { DebugEnterSubRule(34);
			try { DebugEnterDecision(34, false);
			int LA34_1 = input.LA(1);

			if ((LA34_1==AS||LA34_1==IDENT))
			{
				alt34 = 1;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:262:30: asAlias
				{
				DebugLocation(262, 30);
				PushFollow(Follow._asAlias_in_fromClassOrOuterQueryPath1348);
				asAlias93=asAlias();
				PopFollow();

				stream_asAlias.Add(asAlias93.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(34); }

			DebugLocation(262, 40);
			// Hql.g:262:40: ( propertyFetch )?
			int alt35=2;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, false);
			int LA35_1 = input.LA(1);

			if ((LA35_1==FETCH))
			{
				alt35 = 1;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:262:41: propertyFetch
				{
				DebugLocation(262, 41);
				PushFollow(Follow._propertyFetch_in_fromClassOrOuterQueryPath1353);
				propertyFetch94=propertyFetch();
				PopFollow();

				stream_propertyFetch.Add(propertyFetch94.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(35); }



			{
			// AST REWRITE
			// elements: path, asAlias, propertyFetch
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 263:3: -> ^( RANGE path ( asAlias )? ( propertyFetch )? )
			{
				DebugLocation(263, 6);
				// Hql.g:263:6: ^( RANGE path ( asAlias )? ( propertyFetch )? )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(263, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "RANGE"), root_1);

				DebugLocation(263, 14);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(263, 19);
				// Hql.g:263:19: ( asAlias )?
				if (stream_asAlias.HasNext)
				{
					DebugLocation(263, 19);
					adaptor.AddChild(root_1, stream_asAlias.NextTree());

				}
				stream_asAlias.Reset();
				DebugLocation(263, 28);
				// Hql.g:263:28: ( propertyFetch )?
				if (stream_propertyFetch.HasNext)
				{
					DebugLocation(263, 28);
					adaptor.AddChild(root_1, stream_propertyFetch.NextTree());

				}
				stream_propertyFetch.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromClassOrOuterQueryPath", 23);
			LeaveRule("fromClassOrOuterQueryPath", 23);
			LeaveRule_fromClassOrOuterQueryPath();
		}
		DebugLocation(264, 1);
		} finally { DebugExitRule(GrammarFileName, "fromClassOrOuterQueryPath"); }
		return retval;

	}
	// $ANTLR end "fromClassOrOuterQueryPath"

	partial void EnterRule_inClassDeclaration();
	partial void LeaveRule_inClassDeclaration();
	// $ANTLR start "inClassDeclaration"
	// Hql.g:266:1: inClassDeclaration : alias IN ( CLASS )? path -> ^( RANGE path alias ) ;
	[GrammarRule("inClassDeclaration")]
	private AstParserRuleReturnScope<IASTNode, IToken> inClassDeclaration()
	{
		EnterRule_inClassDeclaration();
		EnterRule("inClassDeclaration", 24);
		TraceIn("inClassDeclaration", 24);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken IN96 = default(IToken);
		IToken CLASS97 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> alias95 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path98 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode IN96_tree = default(IASTNode);
		IASTNode CLASS97_tree = default(IASTNode);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleSubtreeStream stream_alias=new RewriteRuleSubtreeStream(adaptor,"rule alias");
		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		try { DebugEnterRule(GrammarFileName, "inClassDeclaration");
		DebugLocation(266, 1);
		try
		{
			// Hql.g:267:2: ( alias IN ( CLASS )? path -> ^( RANGE path alias ) )
			DebugEnterAlt(1);
			// Hql.g:267:4: alias IN ( CLASS )? path
			{
			DebugLocation(267, 4);
			PushFollow(Follow._alias_in_inClassDeclaration1383);
			alias95=alias();
			PopFollow();

			stream_alias.Add(alias95.Tree);
			DebugLocation(267, 10);
			IN96=(IToken)Match(input,IN,Follow._IN_in_inClassDeclaration1385);  
			stream_IN.Add(IN96);

			DebugLocation(267, 13);
			// Hql.g:267:13: ( CLASS )?
			int alt36=2;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, false);
			int LA36_1 = input.LA(1);

			if ((LA36_1==CLASS))
			{
				alt36 = 1;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:267:13: CLASS
				{
				DebugLocation(267, 13);
				CLASS97=(IToken)Match(input,CLASS,Follow._CLASS_in_inClassDeclaration1387);  
				stream_CLASS.Add(CLASS97);


				}
				break;

			}
			} finally { DebugExitSubRule(36); }

			DebugLocation(267, 20);
			PushFollow(Follow._path_in_inClassDeclaration1390);
			path98=path();
			PopFollow();

			stream_path.Add(path98.Tree);


			{
			// AST REWRITE
			// elements: path, alias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 268:3: -> ^( RANGE path alias )
			{
				DebugLocation(268, 6);
				// Hql.g:268:6: ^( RANGE path alias )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(268, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "RANGE"), root_1);

				DebugLocation(268, 14);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(268, 19);
				adaptor.AddChild(root_1, stream_alias.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inClassDeclaration", 24);
			LeaveRule("inClassDeclaration", 24);
			LeaveRule_inClassDeclaration();
		}
		DebugLocation(269, 1);
		} finally { DebugExitRule(GrammarFileName, "inClassDeclaration"); }
		return retval;

	}
	// $ANTLR end "inClassDeclaration"

	partial void EnterRule_inCollectionDeclaration();
	partial void LeaveRule_inCollectionDeclaration();
	// $ANTLR start "inCollectionDeclaration"
	// Hql.g:271:1: inCollectionDeclaration : IN OPEN path CLOSE alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) ;
	[GrammarRule("inCollectionDeclaration")]
	private AstParserRuleReturnScope<IASTNode, IToken> inCollectionDeclaration()
	{
		EnterRule_inCollectionDeclaration();
		EnterRule("inCollectionDeclaration", 25);
		TraceIn("inCollectionDeclaration", 25);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken IN99 = default(IToken);
		IToken OPEN100 = default(IToken);
		IToken CLOSE102 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path101 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> alias103 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode IN99_tree = default(IASTNode);
		IASTNode OPEN100_tree = default(IASTNode);
		IASTNode CLOSE102_tree = default(IASTNode);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		RewriteRuleSubtreeStream stream_alias=new RewriteRuleSubtreeStream(adaptor,"rule alias");
		try { DebugEnterRule(GrammarFileName, "inCollectionDeclaration");
		DebugLocation(271, 4);
		try
		{
			// Hql.g:272:5: ( IN OPEN path CLOSE alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) )
			DebugEnterAlt(1);
			// Hql.g:272:7: IN OPEN path CLOSE alias
			{
			DebugLocation(272, 7);
			IN99=(IToken)Match(input,IN,Follow._IN_in_inCollectionDeclaration1418);  
			stream_IN.Add(IN99);

			DebugLocation(272, 10);
			OPEN100=(IToken)Match(input,OPEN,Follow._OPEN_in_inCollectionDeclaration1420);  
			stream_OPEN.Add(OPEN100);

			DebugLocation(272, 15);
			PushFollow(Follow._path_in_inCollectionDeclaration1422);
			path101=path();
			PopFollow();

			stream_path.Add(path101.Tree);
			DebugLocation(272, 20);
			CLOSE102=(IToken)Match(input,CLOSE,Follow._CLOSE_in_inCollectionDeclaration1424);  
			stream_CLOSE.Add(CLOSE102);

			DebugLocation(272, 26);
			PushFollow(Follow._alias_in_inCollectionDeclaration1426);
			alias103=alias();
			PopFollow();

			stream_alias.Add(alias103.Tree);


			{
			// AST REWRITE
			// elements: path, alias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 273:6: -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
			{
				DebugLocation(273, 9);
				// Hql.g:273:9: ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(273, 11);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(JOIN, "join"), root_1);

				DebugLocation(273, 24);
				adaptor.AddChild(root_1, (IASTNode)adaptor.Create(INNER, "inner"));
				DebugLocation(273, 39);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(273, 44);
				adaptor.AddChild(root_1, stream_alias.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inCollectionDeclaration", 25);
			LeaveRule("inCollectionDeclaration", 25);
			LeaveRule_inCollectionDeclaration();
		}
		DebugLocation(274, 4);
		} finally { DebugExitRule(GrammarFileName, "inCollectionDeclaration"); }
		return retval;

	}
	// $ANTLR end "inCollectionDeclaration"

	partial void EnterRule_inCollectionElementsDeclaration();
	partial void LeaveRule_inCollectionElementsDeclaration();
	// $ANTLR start "inCollectionElementsDeclaration"
	// Hql.g:276:1: inCollectionElementsDeclaration : ( alias IN ELEMENTS OPEN path CLOSE -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) | ELEMENTS OPEN path CLOSE AS alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) );
	[GrammarRule("inCollectionElementsDeclaration")]
	private AstParserRuleReturnScope<IASTNode, IToken> inCollectionElementsDeclaration()
	{
		EnterRule_inCollectionElementsDeclaration();
		EnterRule("inCollectionElementsDeclaration", 26);
		TraceIn("inCollectionElementsDeclaration", 26);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken IN105 = default(IToken);
		IToken ELEMENTS106 = default(IToken);
		IToken OPEN107 = default(IToken);
		IToken CLOSE109 = default(IToken);
		IToken ELEMENTS110 = default(IToken);
		IToken OPEN111 = default(IToken);
		IToken CLOSE113 = default(IToken);
		IToken AS114 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> alias104 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path108 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path112 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> alias115 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode IN105_tree = default(IASTNode);
		IASTNode ELEMENTS106_tree = default(IASTNode);
		IASTNode OPEN107_tree = default(IASTNode);
		IASTNode CLOSE109_tree = default(IASTNode);
		IASTNode ELEMENTS110_tree = default(IASTNode);
		IASTNode OPEN111_tree = default(IASTNode);
		IASTNode CLOSE113_tree = default(IASTNode);
		IASTNode AS114_tree = default(IASTNode);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_ELEMENTS=new RewriteRuleITokenStream(adaptor,"token ELEMENTS");
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
		RewriteRuleITokenStream stream_AS=new RewriteRuleITokenStream(adaptor,"token AS");
		RewriteRuleSubtreeStream stream_alias=new RewriteRuleSubtreeStream(adaptor,"rule alias");
		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		try { DebugEnterRule(GrammarFileName, "inCollectionElementsDeclaration");
		DebugLocation(276, 4);
		try
		{
			// Hql.g:277:2: ( alias IN ELEMENTS OPEN path CLOSE -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) | ELEMENTS OPEN path CLOSE AS alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) )
			int alt37=2;
			try { DebugEnterDecision(37, false);
			int LA37_1 = input.LA(1);

			if ((LA37_1==IDENT))
			{
				alt37 = 1;
			}
			else if ((LA37_1==ELEMENTS))
			{
				alt37 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 37, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:277:4: alias IN ELEMENTS OPEN path CLOSE
				{
				DebugLocation(277, 4);
				PushFollow(Follow._alias_in_inCollectionElementsDeclaration1460);
				alias104=alias();
				PopFollow();

				stream_alias.Add(alias104.Tree);
				DebugLocation(277, 10);
				IN105=(IToken)Match(input,IN,Follow._IN_in_inCollectionElementsDeclaration1462);  
				stream_IN.Add(IN105);

				DebugLocation(277, 13);
				ELEMENTS106=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_inCollectionElementsDeclaration1464);  
				stream_ELEMENTS.Add(ELEMENTS106);

				DebugLocation(277, 22);
				OPEN107=(IToken)Match(input,OPEN,Follow._OPEN_in_inCollectionElementsDeclaration1466);  
				stream_OPEN.Add(OPEN107);

				DebugLocation(277, 27);
				PushFollow(Follow._path_in_inCollectionElementsDeclaration1468);
				path108=path();
				PopFollow();

				stream_path.Add(path108.Tree);
				DebugLocation(277, 32);
				CLOSE109=(IToken)Match(input,CLOSE,Follow._CLOSE_in_inCollectionElementsDeclaration1470);  
				stream_CLOSE.Add(CLOSE109);



				{
				// AST REWRITE
				// elements: path, alias
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 278:3: -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
				{
					DebugLocation(278, 6);
					// Hql.g:278:6: ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(278, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(JOIN, "join"), root_1);

					DebugLocation(278, 21);
					adaptor.AddChild(root_1, (IASTNode)adaptor.Create(INNER, "inner"));
					DebugLocation(278, 36);
					adaptor.AddChild(root_1, stream_path.NextTree());
					DebugLocation(278, 41);
					adaptor.AddChild(root_1, stream_alias.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:279:4: ELEMENTS OPEN path CLOSE AS alias
				{
				DebugLocation(279, 4);
				ELEMENTS110=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_inCollectionElementsDeclaration1492);  
				stream_ELEMENTS.Add(ELEMENTS110);

				DebugLocation(279, 13);
				OPEN111=(IToken)Match(input,OPEN,Follow._OPEN_in_inCollectionElementsDeclaration1494);  
				stream_OPEN.Add(OPEN111);

				DebugLocation(279, 18);
				PushFollow(Follow._path_in_inCollectionElementsDeclaration1496);
				path112=path();
				PopFollow();

				stream_path.Add(path112.Tree);
				DebugLocation(279, 23);
				CLOSE113=(IToken)Match(input,CLOSE,Follow._CLOSE_in_inCollectionElementsDeclaration1498);  
				stream_CLOSE.Add(CLOSE113);

				DebugLocation(279, 29);
				AS114=(IToken)Match(input,AS,Follow._AS_in_inCollectionElementsDeclaration1500);  
				stream_AS.Add(AS114);

				DebugLocation(279, 32);
				PushFollow(Follow._alias_in_inCollectionElementsDeclaration1502);
				alias115=alias();
				PopFollow();

				stream_alias.Add(alias115.Tree);


				{
				// AST REWRITE
				// elements: path, alias
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 280:3: -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
				{
					DebugLocation(280, 6);
					// Hql.g:280:6: ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(280, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(JOIN, "join"), root_1);

					DebugLocation(280, 21);
					adaptor.AddChild(root_1, (IASTNode)adaptor.Create(INNER, "inner"));
					DebugLocation(280, 36);
					adaptor.AddChild(root_1, stream_path.NextTree());
					DebugLocation(280, 41);
					adaptor.AddChild(root_1, stream_alias.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inCollectionElementsDeclaration", 26);
			LeaveRule("inCollectionElementsDeclaration", 26);
			LeaveRule_inCollectionElementsDeclaration();
		}
		DebugLocation(281, 4);
		} finally { DebugExitRule(GrammarFileName, "inCollectionElementsDeclaration"); }
		return retval;

	}
	// $ANTLR end "inCollectionElementsDeclaration"

	partial void EnterRule_asAlias();
	partial void LeaveRule_asAlias();
	// $ANTLR start "asAlias"
	// Hql.g:284:1: asAlias : ( AS !)? alias ;
	[GrammarRule("asAlias")]
	private AstParserRuleReturnScope<IASTNode, IToken> asAlias()
	{
		EnterRule_asAlias();
		EnterRule("asAlias", 27);
		TraceIn("asAlias", 27);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken AS116 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> alias117 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode AS116_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "asAlias");
		DebugLocation(284, 1);
		try
		{
			// Hql.g:285:2: ( ( AS !)? alias )
			DebugEnterAlt(1);
			// Hql.g:285:4: ( AS !)? alias
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(285, 4);
			// Hql.g:285:4: ( AS !)?
			int alt38=2;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==AS))
			{
				alt38 = 1;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:285:5: AS !
				{
				DebugLocation(285, 7);
				AS116=(IToken)Match(input,AS,Follow._AS_in_asAlias1534); 

				}
				break;

			}
			} finally { DebugExitSubRule(38); }

			DebugLocation(285, 11);
			PushFollow(Follow._alias_in_asAlias1539);
			alias117=alias();
			PopFollow();

			adaptor.AddChild(root_0, alias117.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("asAlias", 27);
			LeaveRule("asAlias", 27);
			LeaveRule_asAlias();
		}
		DebugLocation(286, 1);
		} finally { DebugExitRule(GrammarFileName, "asAlias"); }
		return retval;

	}
	// $ANTLR end "asAlias"

	partial void EnterRule_alias();
	partial void LeaveRule_alias();
	// $ANTLR start "alias"
	// Hql.g:287:1: alias : i= identifier -> ^( ALIAS[$i.start] ) ;
	[GrammarRule("alias")]
	private AstParserRuleReturnScope<IASTNode, IToken> alias()
	{
		EnterRule_alias();
		EnterRule("alias", 28);
		TraceIn("alias", 28);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> i = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "alias");
		DebugLocation(287, 1);
		try
		{
			// Hql.g:288:2: (i= identifier -> ^( ALIAS[$i.start] ) )
			DebugEnterAlt(1);
			// Hql.g:288:4: i= identifier
			{
			DebugLocation(288, 5);
			PushFollow(Follow._identifier_in_alias1551);
			i=identifier();
			PopFollow();

			stream_identifier.Add(i.Tree);


			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 289:2: -> ^( ALIAS[$i.start] )
			{
				DebugLocation(289, 5);
				// Hql.g:289:5: ^( ALIAS[$i.start] )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(289, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(ALIAS, (i!=null?((IToken)i.Start):default(IToken))), root_1);

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("alias", 28);
			LeaveRule("alias", 28);
			LeaveRule_alias();
		}
		DebugLocation(290, 1);
		} finally { DebugExitRule(GrammarFileName, "alias"); }
		return retval;

	}
	// $ANTLR end "alias"

	partial void EnterRule_propertyFetch();
	partial void LeaveRule_propertyFetch();
	// $ANTLR start "propertyFetch"
	// Hql.g:292:1: propertyFetch : FETCH ALL ! PROPERTIES !;
	[GrammarRule("propertyFetch")]
	private AstParserRuleReturnScope<IASTNode, IToken> propertyFetch()
	{
		EnterRule_propertyFetch();
		EnterRule("propertyFetch", 29);
		TraceIn("propertyFetch", 29);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken FETCH118 = default(IToken);
		IToken ALL119 = default(IToken);
		IToken PROPERTIES120 = default(IToken);

		IASTNode FETCH118_tree = default(IASTNode);
		IASTNode ALL119_tree = default(IASTNode);
		IASTNode PROPERTIES120_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "propertyFetch");
		DebugLocation(292, 1);
		try
		{
			// Hql.g:293:2: ( FETCH ALL ! PROPERTIES !)
			DebugEnterAlt(1);
			// Hql.g:293:4: FETCH ALL ! PROPERTIES !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(293, 4);
			FETCH118=(IToken)Match(input,FETCH,Follow._FETCH_in_propertyFetch1570); 
			FETCH118_tree = (IASTNode)adaptor.Create(FETCH118);
			adaptor.AddChild(root_0, FETCH118_tree);
			DebugLocation(293, 13);
			ALL119=(IToken)Match(input,ALL,Follow._ALL_in_propertyFetch1572); 
			DebugLocation(293, 25);
			PROPERTIES120=(IToken)Match(input,PROPERTIES,Follow._PROPERTIES_in_propertyFetch1575); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyFetch", 29);
			LeaveRule("propertyFetch", 29);
			LeaveRule_propertyFetch();
		}
		DebugLocation(294, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyFetch"); }
		return retval;

	}
	// $ANTLR end "propertyFetch"

	partial void EnterRule_groupByClause();
	partial void LeaveRule_groupByClause();
	// $ANTLR start "groupByClause"
	// Hql.g:296:1: groupByClause : GROUP ^ 'by' ! expression ( COMMA ! expression )* ;
	[GrammarRule("groupByClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> groupByClause()
	{
		EnterRule_groupByClause();
		EnterRule("groupByClause", 30);
		TraceIn("groupByClause", 30);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken GROUP121 = default(IToken);
		IToken string_literal122 = default(IToken);
		IToken COMMA124 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> expression123 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression125 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode GROUP121_tree = default(IASTNode);
		IASTNode string_literal122_tree = default(IASTNode);
		IASTNode COMMA124_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "groupByClause");
		DebugLocation(296, 1);
		try
		{
			// Hql.g:297:2: ( GROUP ^ 'by' ! expression ( COMMA ! expression )* )
			DebugEnterAlt(1);
			// Hql.g:297:4: GROUP ^ 'by' ! expression ( COMMA ! expression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(297, 9);
			GROUP121=(IToken)Match(input,GROUP,Follow._GROUP_in_groupByClause1587); 
			GROUP121_tree = (IASTNode)adaptor.Create(GROUP121);
			root_0 = (IASTNode)adaptor.BecomeRoot(GROUP121_tree, root_0);
			DebugLocation(298, 7);
			string_literal122=(IToken)Match(input,LITERAL_by,Follow._LITERAL_by_in_groupByClause1593); 
			DebugLocation(298, 9);
			PushFollow(Follow._expression_in_groupByClause1596);
			expression123=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression123.Tree);
			DebugLocation(298, 20);
			// Hql.g:298:20: ( COMMA ! expression )*
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=2;
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if ((LA39_1==COMMA))
				{
					alt39 = 1;
				}


				} finally { DebugExitDecision(39); }
				switch ( alt39 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:298:22: COMMA ! expression
					{
					DebugLocation(298, 27);
					COMMA124=(IToken)Match(input,COMMA,Follow._COMMA_in_groupByClause1600); 
					DebugLocation(298, 29);
					PushFollow(Follow._expression_in_groupByClause1603);
					expression125=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression125.Tree);

					}
					break;

				default:
					goto loop39;
				}
			}

			loop39:
				;

			} finally { DebugExitSubRule(39); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("groupByClause", 30);
			LeaveRule("groupByClause", 30);
			LeaveRule_groupByClause();
		}
		DebugLocation(299, 1);
		} finally { DebugExitRule(GrammarFileName, "groupByClause"); }
		return retval;

	}
	// $ANTLR end "groupByClause"

	partial void EnterRule_orderByClause();
	partial void LeaveRule_orderByClause();
	// $ANTLR start "orderByClause"
	// Hql.g:301:1: orderByClause : ORDER ^ 'by' ! orderElement ( COMMA ! orderElement )* ;
	[GrammarRule("orderByClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> orderByClause()
	{
		EnterRule_orderByClause();
		EnterRule("orderByClause", 31);
		TraceIn("orderByClause", 31);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken ORDER126 = default(IToken);
		IToken string_literal127 = default(IToken);
		IToken COMMA129 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> orderElement128 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> orderElement130 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode ORDER126_tree = default(IASTNode);
		IASTNode string_literal127_tree = default(IASTNode);
		IASTNode COMMA129_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "orderByClause");
		DebugLocation(301, 1);
		try
		{
			// Hql.g:302:2: ( ORDER ^ 'by' ! orderElement ( COMMA ! orderElement )* )
			DebugEnterAlt(1);
			// Hql.g:302:4: ORDER ^ 'by' ! orderElement ( COMMA ! orderElement )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(302, 9);
			ORDER126=(IToken)Match(input,ORDER,Follow._ORDER_in_orderByClause1617); 
			ORDER126_tree = (IASTNode)adaptor.Create(ORDER126);
			root_0 = (IASTNode)adaptor.BecomeRoot(ORDER126_tree, root_0);
			DebugLocation(302, 15);
			string_literal127=(IToken)Match(input,LITERAL_by,Follow._LITERAL_by_in_orderByClause1620); 
			DebugLocation(302, 17);
			PushFollow(Follow._orderElement_in_orderByClause1623);
			orderElement128=orderElement();
			PopFollow();

			adaptor.AddChild(root_0, orderElement128.Tree);
			DebugLocation(302, 30);
			// Hql.g:302:30: ( COMMA ! orderElement )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==COMMA))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:302:32: COMMA ! orderElement
					{
					DebugLocation(302, 37);
					COMMA129=(IToken)Match(input,COMMA,Follow._COMMA_in_orderByClause1627); 
					DebugLocation(302, 39);
					PushFollow(Follow._orderElement_in_orderByClause1630);
					orderElement130=orderElement();
					PopFollow();

					adaptor.AddChild(root_0, orderElement130.Tree);

					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("orderByClause", 31);
			LeaveRule("orderByClause", 31);
			LeaveRule_orderByClause();
		}
		DebugLocation(303, 1);
		} finally { DebugExitRule(GrammarFileName, "orderByClause"); }
		return retval;

	}
	// $ANTLR end "orderByClause"

	partial void EnterRule_skipClause();
	partial void LeaveRule_skipClause();
	// $ANTLR start "skipClause"
	// Hql.g:305:1: skipClause : SKIP ^ ( NUM_INT | parameter ) ;
	[GrammarRule("skipClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> skipClause()
	{
		EnterRule_skipClause();
		EnterRule("skipClause", 32);
		TraceIn("skipClause", 32);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken SKIP131 = default(IToken);
		IToken NUM_INT132 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> parameter133 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode SKIP131_tree = default(IASTNode);
		IASTNode NUM_INT132_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "skipClause");
		DebugLocation(305, 1);
		try
		{
			// Hql.g:306:2: ( SKIP ^ ( NUM_INT | parameter ) )
			DebugEnterAlt(1);
			// Hql.g:306:4: SKIP ^ ( NUM_INT | parameter )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(306, 8);
			SKIP131=(IToken)Match(input,SKIP,Follow._SKIP_in_skipClause1644); 
			SKIP131_tree = (IASTNode)adaptor.Create(SKIP131);
			root_0 = (IASTNode)adaptor.BecomeRoot(SKIP131_tree, root_0);
			DebugLocation(306, 10);
			// Hql.g:306:10: ( NUM_INT | parameter )
			int alt41=2;
			try { DebugEnterSubRule(41);
			try { DebugEnterDecision(41, false);
			int LA41_1 = input.LA(1);

			if ((LA41_1==NUM_INT))
			{
				alt41 = 1;
			}
			else if ((LA41_1==COLON||LA41_1==PARAM))
			{
				alt41 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:306:11: NUM_INT
				{
				DebugLocation(306, 11);
				NUM_INT132=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_skipClause1648); 
				NUM_INT132_tree = (IASTNode)adaptor.Create(NUM_INT132);
				adaptor.AddChild(root_0, NUM_INT132_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:306:21: parameter
				{
				DebugLocation(306, 21);
				PushFollow(Follow._parameter_in_skipClause1652);
				parameter133=parameter();
				PopFollow();

				adaptor.AddChild(root_0, parameter133.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(41); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("skipClause", 32);
			LeaveRule("skipClause", 32);
			LeaveRule_skipClause();
		}
		DebugLocation(307, 1);
		} finally { DebugExitRule(GrammarFileName, "skipClause"); }
		return retval;

	}
	// $ANTLR end "skipClause"

	partial void EnterRule_takeClause();
	partial void LeaveRule_takeClause();
	// $ANTLR start "takeClause"
	// Hql.g:309:1: takeClause : TAKE ^ ( NUM_INT | parameter ) ;
	[GrammarRule("takeClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> takeClause()
	{
		EnterRule_takeClause();
		EnterRule("takeClause", 33);
		TraceIn("takeClause", 33);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken TAKE134 = default(IToken);
		IToken NUM_INT135 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> parameter136 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode TAKE134_tree = default(IASTNode);
		IASTNode NUM_INT135_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "takeClause");
		DebugLocation(309, 1);
		try
		{
			// Hql.g:310:2: ( TAKE ^ ( NUM_INT | parameter ) )
			DebugEnterAlt(1);
			// Hql.g:310:4: TAKE ^ ( NUM_INT | parameter )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(310, 8);
			TAKE134=(IToken)Match(input,TAKE,Follow._TAKE_in_takeClause1664); 
			TAKE134_tree = (IASTNode)adaptor.Create(TAKE134);
			root_0 = (IASTNode)adaptor.BecomeRoot(TAKE134_tree, root_0);
			DebugLocation(310, 10);
			// Hql.g:310:10: ( NUM_INT | parameter )
			int alt42=2;
			try { DebugEnterSubRule(42);
			try { DebugEnterDecision(42, false);
			int LA42_1 = input.LA(1);

			if ((LA42_1==NUM_INT))
			{
				alt42 = 1;
			}
			else if ((LA42_1==COLON||LA42_1==PARAM))
			{
				alt42 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 42, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:310:11: NUM_INT
				{
				DebugLocation(310, 11);
				NUM_INT135=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_takeClause1668); 
				NUM_INT135_tree = (IASTNode)adaptor.Create(NUM_INT135);
				adaptor.AddChild(root_0, NUM_INT135_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:310:21: parameter
				{
				DebugLocation(310, 21);
				PushFollow(Follow._parameter_in_takeClause1672);
				parameter136=parameter();
				PopFollow();

				adaptor.AddChild(root_0, parameter136.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(42); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("takeClause", 33);
			LeaveRule("takeClause", 33);
			LeaveRule_takeClause();
		}
		DebugLocation(311, 1);
		} finally { DebugExitRule(GrammarFileName, "takeClause"); }
		return retval;

	}
	// $ANTLR end "takeClause"

	partial void EnterRule_parameter();
	partial void LeaveRule_parameter();
	// $ANTLR start "parameter"
	// Hql.g:313:1: parameter : ( COLON ^ identifier | PARAM ^ ( NUM_INT )? );
	[GrammarRule("parameter")]
	private AstParserRuleReturnScope<IASTNode, IToken> parameter()
	{
		EnterRule_parameter();
		EnterRule("parameter", 34);
		TraceIn("parameter", 34);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken COLON137 = default(IToken);
		IToken PARAM139 = default(IToken);
		IToken NUM_INT140 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identifier138 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode COLON137_tree = default(IASTNode);
		IASTNode PARAM139_tree = default(IASTNode);
		IASTNode NUM_INT140_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "parameter");
		DebugLocation(313, 1);
		try
		{
			// Hql.g:314:2: ( COLON ^ identifier | PARAM ^ ( NUM_INT )? )
			int alt44=2;
			try { DebugEnterDecision(44, false);
			int LA44_1 = input.LA(1);

			if ((LA44_1==COLON))
			{
				alt44 = 1;
			}
			else if ((LA44_1==PARAM))
			{
				alt44 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 44, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:314:4: COLON ^ identifier
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(314, 9);
				COLON137=(IToken)Match(input,COLON,Follow._COLON_in_parameter1684); 
				COLON137_tree = (IASTNode)adaptor.Create(COLON137);
				root_0 = (IASTNode)adaptor.BecomeRoot(COLON137_tree, root_0);
				DebugLocation(314, 11);
				PushFollow(Follow._identifier_in_parameter1687);
				identifier138=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier138.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:315:4: PARAM ^ ( NUM_INT )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(315, 9);
				PARAM139=(IToken)Match(input,PARAM,Follow._PARAM_in_parameter1692); 
				PARAM139_tree = (IASTNode)adaptor.Create(PARAM139);
				root_0 = (IASTNode)adaptor.BecomeRoot(PARAM139_tree, root_0);
				DebugLocation(315, 11);
				// Hql.g:315:11: ( NUM_INT )?
				int alt43=2;
				try { DebugEnterSubRule(43);
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if ((LA43_1==NUM_INT))
				{
					alt43 = 1;
				}
				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:315:12: NUM_INT
					{
					DebugLocation(315, 12);
					NUM_INT140=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_parameter1696); 
					NUM_INT140_tree = (IASTNode)adaptor.Create(NUM_INT140);
					adaptor.AddChild(root_0, NUM_INT140_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(43); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameter", 34);
			LeaveRule("parameter", 34);
			LeaveRule_parameter();
		}
		DebugLocation(316, 1);
		} finally { DebugExitRule(GrammarFileName, "parameter"); }
		return retval;

	}
	// $ANTLR end "parameter"

	partial void EnterRule_orderElement();
	partial void LeaveRule_orderElement();
	// $ANTLR start "orderElement"
	// Hql.g:318:1: orderElement : expression ( ascendingOrDescending )? ;
	[GrammarRule("orderElement")]
	private AstParserRuleReturnScope<IASTNode, IToken> orderElement()
	{
		EnterRule_orderElement();
		EnterRule("orderElement", 35);
		TraceIn("orderElement", 35);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> expression141 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> ascendingOrDescending142 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "orderElement");
		DebugLocation(318, 1);
		try
		{
			// Hql.g:319:2: ( expression ( ascendingOrDescending )? )
			DebugEnterAlt(1);
			// Hql.g:319:4: expression ( ascendingOrDescending )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(319, 4);
			PushFollow(Follow._expression_in_orderElement1709);
			expression141=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression141.Tree);
			DebugLocation(319, 15);
			// Hql.g:319:15: ( ascendingOrDescending )?
			int alt45=2;
			try { DebugEnterSubRule(45);
			try { DebugEnterDecision(45, false);
			int LA45_1 = input.LA(1);

			if ((LA45_1==ASCENDING||LA45_1==DESCENDING||(LA45_1>=133 && LA45_1<=134)))
			{
				alt45 = 1;
			}
			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:319:17: ascendingOrDescending
				{
				DebugLocation(319, 17);
				PushFollow(Follow._ascendingOrDescending_in_orderElement1713);
				ascendingOrDescending142=ascendingOrDescending();
				PopFollow();

				adaptor.AddChild(root_0, ascendingOrDescending142.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(45); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("orderElement", 35);
			LeaveRule("orderElement", 35);
			LeaveRule_orderElement();
		}
		DebugLocation(320, 1);
		} finally { DebugExitRule(GrammarFileName, "orderElement"); }
		return retval;

	}
	// $ANTLR end "orderElement"

	partial void EnterRule_ascendingOrDescending();
	partial void LeaveRule_ascendingOrDescending();
	// $ANTLR start "ascendingOrDescending"
	// Hql.g:322:1: ascendingOrDescending : ( (a= 'asc' |a= 'ascending' ) -> ^( ASCENDING[$a.Text] ) | (d= 'desc' |d= 'descending' ) -> ^( DESCENDING[$d.Text] ) );
	[GrammarRule("ascendingOrDescending")]
	private AstParserRuleReturnScope<IASTNode, IToken> ascendingOrDescending()
	{
		EnterRule_ascendingOrDescending();
		EnterRule("ascendingOrDescending", 36);
		TraceIn("ascendingOrDescending", 36);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken a = default(IToken);
		IToken d = default(IToken);

		IASTNode a_tree = default(IASTNode);
		IASTNode d_tree = default(IASTNode);
		RewriteRuleITokenStream stream_ASCENDING=new RewriteRuleITokenStream(adaptor,"token ASCENDING");
		RewriteRuleITokenStream stream_133=new RewriteRuleITokenStream(adaptor,"token 133");
		RewriteRuleITokenStream stream_DESCENDING=new RewriteRuleITokenStream(adaptor,"token DESCENDING");
		RewriteRuleITokenStream stream_134=new RewriteRuleITokenStream(adaptor,"token 134");
		try { DebugEnterRule(GrammarFileName, "ascendingOrDescending");
		DebugLocation(322, 1);
		try
		{
			// Hql.g:323:2: ( (a= 'asc' |a= 'ascending' ) -> ^( ASCENDING[$a.Text] ) | (d= 'desc' |d= 'descending' ) -> ^( DESCENDING[$d.Text] ) )
			int alt48=2;
			try { DebugEnterDecision(48, false);
			int LA48_1 = input.LA(1);

			if ((LA48_1==ASCENDING||LA48_1==133))
			{
				alt48 = 1;
			}
			else if ((LA48_1==DESCENDING||LA48_1==134))
			{
				alt48 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 48, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:323:4: (a= 'asc' |a= 'ascending' )
				{
				DebugLocation(323, 4);
				// Hql.g:323:4: (a= 'asc' |a= 'ascending' )
				int alt46=2;
				try { DebugEnterSubRule(46);
				try { DebugEnterDecision(46, false);
				int LA46_1 = input.LA(1);

				if ((LA46_1==ASCENDING))
				{
					alt46 = 1;
				}
				else if ((LA46_1==133))
				{
					alt46 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 46, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(46); }
				switch (alt46)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:323:6: a= 'asc'
					{
					DebugLocation(323, 7);
					a=(IToken)Match(input,ASCENDING,Follow._ASCENDING_in_ascendingOrDescending1731);  
					stream_ASCENDING.Add(a);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:323:16: a= 'ascending'
					{
					DebugLocation(323, 17);
					a=(IToken)Match(input,133,Follow._133_in_ascendingOrDescending1737);  
					stream_133.Add(a);


					}
					break;

				}
				} finally { DebugExitSubRule(46); }



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 324:3: -> ^( ASCENDING[$a.Text] )
				{
					DebugLocation(324, 6);
					// Hql.g:324:6: ^( ASCENDING[$a.Text] )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(324, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(ASCENDING, a.Text), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:325:4: (d= 'desc' |d= 'descending' )
				{
				DebugLocation(325, 4);
				// Hql.g:325:4: (d= 'desc' |d= 'descending' )
				int alt47=2;
				try { DebugEnterSubRule(47);
				try { DebugEnterDecision(47, false);
				int LA47_1 = input.LA(1);

				if ((LA47_1==DESCENDING))
				{
					alt47 = 1;
				}
				else if ((LA47_1==134))
				{
					alt47 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 47, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(47); }
				switch (alt47)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:325:6: d= 'desc'
					{
					DebugLocation(325, 7);
					d=(IToken)Match(input,DESCENDING,Follow._DESCENDING_in_ascendingOrDescending1757);  
					stream_DESCENDING.Add(d);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:325:17: d= 'descending'
					{
					DebugLocation(325, 18);
					d=(IToken)Match(input,134,Follow._134_in_ascendingOrDescending1763);  
					stream_134.Add(d);


					}
					break;

				}
				} finally { DebugExitSubRule(47); }



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 326:3: -> ^( DESCENDING[$d.Text] )
				{
					DebugLocation(326, 6);
					// Hql.g:326:6: ^( DESCENDING[$d.Text] )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(326, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(DESCENDING, d.Text), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ascendingOrDescending", 36);
			LeaveRule("ascendingOrDescending", 36);
			LeaveRule_ascendingOrDescending();
		}
		DebugLocation(327, 1);
		} finally { DebugExitRule(GrammarFileName, "ascendingOrDescending"); }
		return retval;

	}
	// $ANTLR end "ascendingOrDescending"

	partial void EnterRule_havingClause();
	partial void LeaveRule_havingClause();
	// $ANTLR start "havingClause"
	// Hql.g:329:1: havingClause : HAVING ^ logicalExpression ;
	[GrammarRule("havingClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> havingClause()
	{
		EnterRule_havingClause();
		EnterRule("havingClause", 37);
		TraceIn("havingClause", 37);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken HAVING143 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> logicalExpression144 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode HAVING143_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "havingClause");
		DebugLocation(329, 1);
		try
		{
			// Hql.g:330:2: ( HAVING ^ logicalExpression )
			DebugEnterAlt(1);
			// Hql.g:330:4: HAVING ^ logicalExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(330, 10);
			HAVING143=(IToken)Match(input,HAVING,Follow._HAVING_in_havingClause1784); 
			HAVING143_tree = (IASTNode)adaptor.Create(HAVING143);
			root_0 = (IASTNode)adaptor.BecomeRoot(HAVING143_tree, root_0);
			DebugLocation(330, 12);
			PushFollow(Follow._logicalExpression_in_havingClause1787);
			logicalExpression144=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression144.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("havingClause", 37);
			LeaveRule("havingClause", 37);
			LeaveRule_havingClause();
		}
		DebugLocation(331, 1);
		} finally { DebugExitRule(GrammarFileName, "havingClause"); }
		return retval;

	}
	// $ANTLR end "havingClause"

	partial void EnterRule_whereClause();
	partial void LeaveRule_whereClause();
	// $ANTLR start "whereClause"
	// Hql.g:333:1: whereClause : WHERE ^ logicalExpression ;
	[GrammarRule("whereClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> whereClause()
	{
		EnterRule_whereClause();
		EnterRule("whereClause", 38);
		TraceIn("whereClause", 38);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken WHERE145 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> logicalExpression146 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode WHERE145_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "whereClause");
		DebugLocation(333, 1);
		try
		{
			// Hql.g:334:2: ( WHERE ^ logicalExpression )
			DebugEnterAlt(1);
			// Hql.g:334:4: WHERE ^ logicalExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(334, 9);
			WHERE145=(IToken)Match(input,WHERE,Follow._WHERE_in_whereClause1798); 
			WHERE145_tree = (IASTNode)adaptor.Create(WHERE145);
			root_0 = (IASTNode)adaptor.BecomeRoot(WHERE145_tree, root_0);
			DebugLocation(334, 11);
			PushFollow(Follow._logicalExpression_in_whereClause1801);
			logicalExpression146=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression146.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whereClause", 38);
			LeaveRule("whereClause", 38);
			LeaveRule_whereClause();
		}
		DebugLocation(335, 1);
		} finally { DebugExitRule(GrammarFileName, "whereClause"); }
		return retval;

	}
	// $ANTLR end "whereClause"

	partial void EnterRule_selectedPropertiesList();
	partial void LeaveRule_selectedPropertiesList();
	// $ANTLR start "selectedPropertiesList"
	// Hql.g:337:1: selectedPropertiesList : aliasedExpression ( COMMA ! aliasedExpression )* ;
	[GrammarRule("selectedPropertiesList")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectedPropertiesList()
	{
		EnterRule_selectedPropertiesList();
		EnterRule("selectedPropertiesList", 39);
		TraceIn("selectedPropertiesList", 39);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken COMMA148 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> aliasedExpression147 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> aliasedExpression149 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode COMMA148_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "selectedPropertiesList");
		DebugLocation(337, 1);
		try
		{
			// Hql.g:338:2: ( aliasedExpression ( COMMA ! aliasedExpression )* )
			DebugEnterAlt(1);
			// Hql.g:338:4: aliasedExpression ( COMMA ! aliasedExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(338, 4);
			PushFollow(Follow._aliasedExpression_in_selectedPropertiesList1812);
			aliasedExpression147=aliasedExpression();
			PopFollow();

			adaptor.AddChild(root_0, aliasedExpression147.Tree);
			DebugLocation(338, 22);
			// Hql.g:338:22: ( COMMA ! aliasedExpression )*
			try { DebugEnterSubRule(49);
			while (true)
			{
				int alt49=2;
				try { DebugEnterDecision(49, false);
				int LA49_1 = input.LA(1);

				if ((LA49_1==COMMA))
				{
					alt49 = 1;
				}


				} finally { DebugExitDecision(49); }
				switch ( alt49 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:338:24: COMMA ! aliasedExpression
					{
					DebugLocation(338, 29);
					COMMA148=(IToken)Match(input,COMMA,Follow._COMMA_in_selectedPropertiesList1816); 
					DebugLocation(338, 31);
					PushFollow(Follow._aliasedExpression_in_selectedPropertiesList1819);
					aliasedExpression149=aliasedExpression();
					PopFollow();

					adaptor.AddChild(root_0, aliasedExpression149.Tree);

					}
					break;

				default:
					goto loop49;
				}
			}

			loop49:
				;

			} finally { DebugExitSubRule(49); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectedPropertiesList", 39);
			LeaveRule("selectedPropertiesList", 39);
			LeaveRule_selectedPropertiesList();
		}
		DebugLocation(339, 1);
		} finally { DebugExitRule(GrammarFileName, "selectedPropertiesList"); }
		return retval;

	}
	// $ANTLR end "selectedPropertiesList"

	partial void EnterRule_aliasedExpression();
	partial void LeaveRule_aliasedExpression();
	// $ANTLR start "aliasedExpression"
	// Hql.g:341:1: aliasedExpression : expression ( AS ^ identifier )? ;
	[GrammarRule("aliasedExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> aliasedExpression()
	{
		EnterRule_aliasedExpression();
		EnterRule("aliasedExpression", 40);
		TraceIn("aliasedExpression", 40);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken AS151 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> expression150 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier152 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode AS151_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "aliasedExpression");
		DebugLocation(341, 1);
		try
		{
			// Hql.g:342:2: ( expression ( AS ^ identifier )? )
			DebugEnterAlt(1);
			// Hql.g:342:4: expression ( AS ^ identifier )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(342, 4);
			PushFollow(Follow._expression_in_aliasedExpression1834);
			expression150=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression150.Tree);
			DebugLocation(342, 15);
			// Hql.g:342:15: ( AS ^ identifier )?
			int alt50=2;
			try { DebugEnterSubRule(50);
			try { DebugEnterDecision(50, false);
			int LA50_1 = input.LA(1);

			if ((LA50_1==AS))
			{
				alt50 = 1;
			}
			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:342:17: AS ^ identifier
				{
				DebugLocation(342, 19);
				AS151=(IToken)Match(input,AS,Follow._AS_in_aliasedExpression1838); 
				AS151_tree = (IASTNode)adaptor.Create(AS151);
				root_0 = (IASTNode)adaptor.BecomeRoot(AS151_tree, root_0);
				DebugLocation(342, 21);
				PushFollow(Follow._identifier_in_aliasedExpression1841);
				identifier152=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier152.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(50); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aliasedExpression", 40);
			LeaveRule("aliasedExpression", 40);
			LeaveRule_aliasedExpression();
		}
		DebugLocation(343, 1);
		} finally { DebugExitRule(GrammarFileName, "aliasedExpression"); }
		return retval;

	}
	// $ANTLR end "aliasedExpression"

	partial void EnterRule_logicalExpression();
	partial void LeaveRule_logicalExpression();
	// $ANTLR start "logicalExpression"
	// Hql.g:370:1: logicalExpression : expression ;
	[GrammarRule("logicalExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> logicalExpression()
	{
		EnterRule_logicalExpression();
		EnterRule("logicalExpression", 41);
		TraceIn("logicalExpression", 41);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> expression153 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "logicalExpression");
		DebugLocation(370, 1);
		try
		{
			// Hql.g:371:2: ( expression )
			DebugEnterAlt(1);
			// Hql.g:371:4: expression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(371, 4);
			PushFollow(Follow._expression_in_logicalExpression1880);
			expression153=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression153.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalExpression", 41);
			LeaveRule("logicalExpression", 41);
			LeaveRule_logicalExpression();
		}
		DebugLocation(372, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalExpression"); }
		return retval;

	}
	// $ANTLR end "logicalExpression"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// Hql.g:375:1: expression : logicalOrExpression ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<IASTNode, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 42);
		TraceIn("expression", 42);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> logicalOrExpression154 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(375, 1);
		try
		{
			// Hql.g:376:2: ( logicalOrExpression )
			DebugEnterAlt(1);
			// Hql.g:376:4: logicalOrExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(376, 4);
			PushFollow(Follow._logicalOrExpression_in_expression1892);
			logicalOrExpression154=logicalOrExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalOrExpression154.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 42);
			LeaveRule("expression", 42);
			LeaveRule_expression();
		}
		DebugLocation(377, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_logicalOrExpression();
	partial void LeaveRule_logicalOrExpression();
	// $ANTLR start "logicalOrExpression"
	// Hql.g:380:1: logicalOrExpression : logicalAndExpression ( OR ^ logicalAndExpression )* ;
	[GrammarRule("logicalOrExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> logicalOrExpression()
	{
		EnterRule_logicalOrExpression();
		EnterRule("logicalOrExpression", 43);
		TraceIn("logicalOrExpression", 43);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken OR156 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> logicalAndExpression155 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> logicalAndExpression157 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode OR156_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "logicalOrExpression");
		DebugLocation(380, 1);
		try
		{
			// Hql.g:381:2: ( logicalAndExpression ( OR ^ logicalAndExpression )* )
			DebugEnterAlt(1);
			// Hql.g:381:4: logicalAndExpression ( OR ^ logicalAndExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(381, 4);
			PushFollow(Follow._logicalAndExpression_in_logicalOrExpression1904);
			logicalAndExpression155=logicalAndExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalAndExpression155.Tree);
			DebugLocation(381, 25);
			// Hql.g:381:25: ( OR ^ logicalAndExpression )*
			try { DebugEnterSubRule(51);
			while (true)
			{
				int alt51=2;
				try { DebugEnterDecision(51, false);
				int LA51_1 = input.LA(1);

				if ((LA51_1==OR))
				{
					alt51 = 1;
				}


				} finally { DebugExitDecision(51); }
				switch ( alt51 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:381:27: OR ^ logicalAndExpression
					{
					DebugLocation(381, 29);
					OR156=(IToken)Match(input,OR,Follow._OR_in_logicalOrExpression1908); 
					OR156_tree = (IASTNode)adaptor.Create(OR156);
					root_0 = (IASTNode)adaptor.BecomeRoot(OR156_tree, root_0);
					DebugLocation(381, 31);
					PushFollow(Follow._logicalAndExpression_in_logicalOrExpression1911);
					logicalAndExpression157=logicalAndExpression();
					PopFollow();

					adaptor.AddChild(root_0, logicalAndExpression157.Tree);

					}
					break;

				default:
					goto loop51;
				}
			}

			loop51:
				;

			} finally { DebugExitSubRule(51); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalOrExpression", 43);
			LeaveRule("logicalOrExpression", 43);
			LeaveRule_logicalOrExpression();
		}
		DebugLocation(382, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalOrExpression"); }
		return retval;

	}
	// $ANTLR end "logicalOrExpression"

	partial void EnterRule_logicalAndExpression();
	partial void LeaveRule_logicalAndExpression();
	// $ANTLR start "logicalAndExpression"
	// Hql.g:385:1: logicalAndExpression : negatedExpression ( AND ^ negatedExpression )* ;
	[GrammarRule("logicalAndExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> logicalAndExpression()
	{
		EnterRule_logicalAndExpression();
		EnterRule("logicalAndExpression", 44);
		TraceIn("logicalAndExpression", 44);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken AND159 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> negatedExpression158 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> negatedExpression160 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode AND159_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "logicalAndExpression");
		DebugLocation(385, 1);
		try
		{
			// Hql.g:386:2: ( negatedExpression ( AND ^ negatedExpression )* )
			DebugEnterAlt(1);
			// Hql.g:386:4: negatedExpression ( AND ^ negatedExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(386, 4);
			PushFollow(Follow._negatedExpression_in_logicalAndExpression1926);
			negatedExpression158=negatedExpression();
			PopFollow();

			adaptor.AddChild(root_0, negatedExpression158.Tree);
			DebugLocation(386, 22);
			// Hql.g:386:22: ( AND ^ negatedExpression )*
			try { DebugEnterSubRule(52);
			while (true)
			{
				int alt52=2;
				try { DebugEnterDecision(52, false);
				int LA52_1 = input.LA(1);

				if ((LA52_1==AND))
				{
					alt52 = 1;
				}


				} finally { DebugExitDecision(52); }
				switch ( alt52 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:386:24: AND ^ negatedExpression
					{
					DebugLocation(386, 27);
					AND159=(IToken)Match(input,AND,Follow._AND_in_logicalAndExpression1930); 
					AND159_tree = (IASTNode)adaptor.Create(AND159);
					root_0 = (IASTNode)adaptor.BecomeRoot(AND159_tree, root_0);
					DebugLocation(386, 29);
					PushFollow(Follow._negatedExpression_in_logicalAndExpression1933);
					negatedExpression160=negatedExpression();
					PopFollow();

					adaptor.AddChild(root_0, negatedExpression160.Tree);

					}
					break;

				default:
					goto loop52;
				}
			}

			loop52:
				;

			} finally { DebugExitSubRule(52); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalAndExpression", 44);
			LeaveRule("logicalAndExpression", 44);
			LeaveRule_logicalAndExpression();
		}
		DebugLocation(387, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalAndExpression"); }
		return retval;

	}
	// $ANTLR end "logicalAndExpression"

	partial void EnterRule_negatedExpression();
	partial void LeaveRule_negatedExpression();
	// $ANTLR start "negatedExpression"
	// Hql.g:391:1: negatedExpression : ( NOT x= negatedExpression -> ^() | equalityExpression );
	[GrammarRule("negatedExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> negatedExpression()
	{
		EnterRule_negatedExpression();
		EnterRule("negatedExpression", 45);
		TraceIn("negatedExpression", 45);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken NOT161 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> x = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> equalityExpression162 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode NOT161_tree = default(IASTNode);
		RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_negatedExpression=new RewriteRuleSubtreeStream(adaptor,"rule negatedExpression");
		 WeakKeywords(); 
		try { DebugEnterRule(GrammarFileName, "negatedExpression");
		DebugLocation(391, 1);
		try
		{
			// Hql.g:393:2: ( NOT x= negatedExpression -> ^() | equalityExpression )
			int alt53=2;
			try { DebugEnterDecision(53, false);
			int LA53_1 = input.LA(1);

			if ((LA53_1==NOT))
			{
				alt53 = 1;
			}
			else if ((LA53_1==ALL||LA53_1==ANY||LA53_1==AVG||LA53_1==BNOT||LA53_1==CASE||LA53_1==COLON||LA53_1==COUNT||LA53_1==ELEMENTS||LA53_1==EMPTY||LA53_1==EXISTS||LA53_1==FALSE||LA53_1==IDENT||LA53_1==INDICES||LA53_1==MAX||(LA53_1>=MIN && LA53_1<=MINUS)||(LA53_1>=NULL && LA53_1<=NUM_LONG)||LA53_1==OPEN||(LA53_1>=PARAM && LA53_1<=PLUS)||LA53_1==QUOTED_String||LA53_1==SOME||LA53_1==SUM||LA53_1==TRUE))
			{
				alt53 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 53, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:393:4: NOT x= negatedExpression
				{
				DebugLocation(393, 4);
				NOT161=(IToken)Match(input,NOT,Follow._NOT_in_negatedExpression1954);  
				stream_NOT.Add(NOT161);

				DebugLocation(393, 9);
				PushFollow(Follow._negatedExpression_in_negatedExpression1958);
				x=negatedExpression();
				PopFollow();

				stream_negatedExpression.Add(x.Tree);


				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 394:3: -> ^()
				{
					DebugLocation(394, 6);
					// Hql.g:394:6: ^()
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(394, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot(NegateNode((x!=null?((IASTNode)x.Tree):default(IASTNode))), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:395:4: equalityExpression
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(395, 4);
				PushFollow(Follow._equalityExpression_in_negatedExpression1971);
				equalityExpression162=equalityExpression();
				PopFollow();

				adaptor.AddChild(root_0, equalityExpression162.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("negatedExpression", 45);
			LeaveRule("negatedExpression", 45);
			LeaveRule_negatedExpression();
		}
		DebugLocation(396, 1);
		} finally { DebugExitRule(GrammarFileName, "negatedExpression"); }
		return retval;

	}
	// $ANTLR end "negatedExpression"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// Hql.g:401:1: equalityExpression : x= relationalExpression ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 46);
		TraceIn("equalityExpression", 46);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken isx = default(IToken);
		IToken ne = default(IToken);
		IToken EQ163 = default(IToken);
		IToken NOT164 = default(IToken);
		IToken NE165 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> x = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> y = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode isx_tree = default(IASTNode);
		IASTNode ne_tree = default(IASTNode);
		IASTNode EQ163_tree = default(IASTNode);
		IASTNode NOT164_tree = default(IASTNode);
		IASTNode NE165_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(401, 1);
		try
		{
			// Hql.g:406:2: (x= relationalExpression ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )* )
			DebugEnterAlt(1);
			// Hql.g:406:4: x= relationalExpression ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(406, 5);
			PushFollow(Follow._relationalExpression_in_equalityExpression1993);
			x=relationalExpression();
			PopFollow();

			adaptor.AddChild(root_0, x.Tree);
			DebugLocation(406, 27);
			// Hql.g:406:27: ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )*
			try { DebugEnterSubRule(56);
			while (true)
			{
				int alt56=2;
				try { DebugEnterDecision(56, false);
				int LA56_1 = input.LA(1);

				if ((LA56_1==EQ||LA56_1==IS||LA56_1==NE||LA56_1==SQL_NE))
				{
					alt56 = 1;
				}


				} finally { DebugExitDecision(56); }
				switch ( alt56 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:407:3: ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression
					{
					DebugLocation(407, 3);
					// Hql.g:407:3: ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^)
					int alt55=4;
					try { DebugEnterSubRule(55);
					try { DebugEnterDecision(55, false);
					switch (input.LA(1))
					{
					case EQ:
						{
						alt55 = 1;
						}
						break;
					case IS:
						{
						alt55 = 2;
						}
						break;
					case NE:
						{
						alt55 = 3;
						}
						break;
					case SQL_NE:
						{
						alt55 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 55, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(55); }
					switch (alt55)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:407:5: EQ ^
						{
						DebugLocation(407, 7);
						EQ163=(IToken)Match(input,EQ,Follow._EQ_in_equalityExpression2001); 
						EQ163_tree = (IASTNode)adaptor.Create(EQ163);
						root_0 = (IASTNode)adaptor.BecomeRoot(EQ163_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Hql.g:408:5: isx= IS ^ ( NOT !)?
						{
						DebugLocation(408, 8);
						isx=(IToken)Match(input,IS,Follow._IS_in_equalityExpression2010); 
						isx_tree = (IASTNode)adaptor.Create(isx);
						root_0 = (IASTNode)adaptor.BecomeRoot(isx_tree, root_0);
						DebugLocation(408, 13);
						 isx.Type = EQ; 
						DebugLocation(408, 33);
						// Hql.g:408:33: ( NOT !)?
						int alt54=2;
						try { DebugEnterSubRule(54);
						try { DebugEnterDecision(54, false);
						int LA54_1 = input.LA(1);

						if ((LA54_1==NOT))
						{
							alt54 = 1;
						}
						} finally { DebugExitDecision(54); }
						switch (alt54)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:408:34: NOT !
							{
							DebugLocation(408, 37);
							NOT164=(IToken)Match(input,NOT,Follow._NOT_in_equalityExpression2016); 
							DebugLocation(408, 39);
							 isx.Type =NE; 

							}
							break;

						}
						} finally { DebugExitSubRule(54); }


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Hql.g:409:5: NE ^
						{
						DebugLocation(409, 7);
						NE165=(IToken)Match(input,NE,Follow._NE_in_equalityExpression2028); 
						NE165_tree = (IASTNode)adaptor.Create(NE165);
						root_0 = (IASTNode)adaptor.BecomeRoot(NE165_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// Hql.g:410:5: ne= SQL_NE ^
						{
						DebugLocation(410, 7);
						ne=(IToken)Match(input,SQL_NE,Follow._SQL_NE_in_equalityExpression2037); 
						ne_tree = (IASTNode)adaptor.Create(ne);
						root_0 = (IASTNode)adaptor.BecomeRoot(ne_tree, root_0);
						DebugLocation(410, 16);
						 ne.Type = NE; 

						}
						break;

					}
					} finally { DebugExitSubRule(55); }

					DebugLocation(411, 6);
					PushFollow(Follow._relationalExpression_in_equalityExpression2048);
					y=relationalExpression();
					PopFollow();

					adaptor.AddChild(root_0, y.Tree);

					}
					break;

				default:
					goto loop56;
				}
			}

			loop56:
				;

			} finally { DebugExitSubRule(56); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);


						// Post process the equality expression to clean up 'is null', etc.
						retval.Tree =  ProcessEqualityExpression(retval.Tree);
					
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 46);
			LeaveRule("equalityExpression", 46);
			LeaveRule_equalityExpression();
		}
		DebugLocation(412, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// Hql.g:418:1: relationalExpression : concatenation ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) ) ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 47);
		TraceIn("relationalExpression", 47);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken n = default(IToken);
		IToken i = default(IToken);
		IToken b = default(IToken);
		IToken l = default(IToken);
		IToken LT167 = default(IToken);
		IToken GT168 = default(IToken);
		IToken LE169 = default(IToken);
		IToken GE170 = default(IToken);
		IToken MEMBER176 = default(IToken);
		IToken OF177 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> p = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> concatenation166 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression171 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> inList172 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> betweenList173 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> concatenation174 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> likeEscape175 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode n_tree = default(IASTNode);
		IASTNode i_tree = default(IASTNode);
		IASTNode b_tree = default(IASTNode);
		IASTNode l_tree = default(IASTNode);
		IASTNode LT167_tree = default(IASTNode);
		IASTNode GT168_tree = default(IASTNode);
		IASTNode LE169_tree = default(IASTNode);
		IASTNode GE170_tree = default(IASTNode);
		IASTNode MEMBER176_tree = default(IASTNode);
		IASTNode OF177_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(418, 1);
		try
		{
			// Hql.g:419:2: ( concatenation ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) ) )
			DebugEnterAlt(1);
			// Hql.g:419:4: concatenation ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(419, 4);
			PushFollow(Follow._concatenation_in_relationalExpression2065);
			concatenation166=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation166.Tree);
			DebugLocation(419, 18);
			// Hql.g:419:18: ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) )
			int alt62=2;
			try { DebugEnterSubRule(62);
			try { DebugEnterDecision(62, false);
			int LA62_1 = input.LA(1);

			if ((LA62_1==EOF||LA62_1==AND||(LA62_1>=AS && LA62_1<=ASCENDING)||(LA62_1>=CLOSE && LA62_1<=CLOSE_BRACKET)||LA62_1==COMMA||LA62_1==DESCENDING||LA62_1==ELSE||(LA62_1>=END && LA62_1<=EQ)||(LA62_1>=FROM && LA62_1<=HAVING)||LA62_1==INNER||LA62_1==IS||(LA62_1>=JOIN && LA62_1<=LE)||LA62_1==LEFT||LA62_1==LT||LA62_1==NE||(LA62_1>=OR && LA62_1<=ORDER)||LA62_1==RIGHT||LA62_1==SKIP||LA62_1==SQL_NE||(LA62_1>=TAKE && LA62_1<=THEN)||LA62_1==UNION||(LA62_1>=WHEN && LA62_1<=WHERE)||(LA62_1>=133 && LA62_1<=134)))
			{
				alt62 = 1;
			}
			else if ((LA62_1==BETWEEN||LA62_1==IN||LA62_1==LIKE||LA62_1==MEMBER||LA62_1==NOT))
			{
				alt62 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 62, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(62); }
			switch (alt62)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:420:3: ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* )
				{
				DebugLocation(420, 3);
				// Hql.g:420:3: ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* )
				DebugEnterAlt(1);
				// Hql.g:420:5: ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )*
				{
				DebugLocation(420, 5);
				// Hql.g:420:5: ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )*
				try { DebugEnterSubRule(58);
				while (true)
				{
					int alt58=2;
					try { DebugEnterDecision(58, false);
					int LA58_1 = input.LA(1);

					if ((LA58_1==GE||LA58_1==GT||LA58_1==LE||LA58_1==LT))
					{
						alt58 = 1;
					}


					} finally { DebugExitDecision(58); }
					switch ( alt58 )
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:420:7: ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression
						{
						DebugLocation(420, 7);
						// Hql.g:420:7: ( LT ^| GT ^| LE ^| GE ^)
						int alt57=4;
						try { DebugEnterSubRule(57);
						try { DebugEnterDecision(57, false);
						switch (input.LA(1))
						{
						case LT:
							{
							alt57 = 1;
							}
							break;
						case GT:
							{
							alt57 = 2;
							}
							break;
						case LE:
							{
							alt57 = 3;
							}
							break;
						case GE:
							{
							alt57 = 4;
							}
							break;
						default:
							{
								NoViableAltException nvae = new NoViableAltException("", 57, 0, input, 1);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

						} finally { DebugExitDecision(57); }
						switch (alt57)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:420:9: LT ^
							{
							DebugLocation(420, 11);
							LT167=(IToken)Match(input,LT,Follow._LT_in_relationalExpression2077); 
							LT167_tree = (IASTNode)adaptor.Create(LT167);
							root_0 = (IASTNode)adaptor.BecomeRoot(LT167_tree, root_0);

							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Hql.g:420:15: GT ^
							{
							DebugLocation(420, 17);
							GT168=(IToken)Match(input,GT,Follow._GT_in_relationalExpression2082); 
							GT168_tree = (IASTNode)adaptor.Create(GT168);
							root_0 = (IASTNode)adaptor.BecomeRoot(GT168_tree, root_0);

							}
							break;
						case 3:
							DebugEnterAlt(3);
							// Hql.g:420:21: LE ^
							{
							DebugLocation(420, 23);
							LE169=(IToken)Match(input,LE,Follow._LE_in_relationalExpression2087); 
							LE169_tree = (IASTNode)adaptor.Create(LE169);
							root_0 = (IASTNode)adaptor.BecomeRoot(LE169_tree, root_0);

							}
							break;
						case 4:
							DebugEnterAlt(4);
							// Hql.g:420:27: GE ^
							{
							DebugLocation(420, 29);
							GE170=(IToken)Match(input,GE,Follow._GE_in_relationalExpression2092); 
							GE170_tree = (IASTNode)adaptor.Create(GE170);
							root_0 = (IASTNode)adaptor.BecomeRoot(GE170_tree, root_0);

							}
							break;

						}
						} finally { DebugExitSubRule(57); }

						DebugLocation(420, 33);
						PushFollow(Follow._bitwiseNotExpression_in_relationalExpression2097);
						bitwiseNotExpression171=bitwiseNotExpression();
						PopFollow();

						adaptor.AddChild(root_0, bitwiseNotExpression171.Tree);

						}
						break;

					default:
						goto loop58;
					}
				}

				loop58:
					;

				} finally { DebugExitSubRule(58); }


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:422:5: (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) )
				{
				DebugLocation(422, 5);
				// Hql.g:422:5: (n= NOT !)?
				int alt59=2;
				try { DebugEnterSubRule(59);
				try { DebugEnterDecision(59, false);
				int LA59_1 = input.LA(1);

				if ((LA59_1==NOT))
				{
					alt59 = 1;
				}
				} finally { DebugExitDecision(59); }
				switch (alt59)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:422:6: n= NOT !
					{
					DebugLocation(422, 7);
					n=(IToken)Match(input,NOT,Follow._NOT_in_relationalExpression2114); 

					}
					break;

				}
				} finally { DebugExitSubRule(59); }

				DebugLocation(422, 15);
				// Hql.g:422:15: ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) )
				int alt61=4;
				try { DebugEnterSubRule(61);
				try { DebugEnterDecision(61, false);
				switch (input.LA(1))
				{
				case IN:
					{
					alt61 = 1;
					}
					break;
				case BETWEEN:
					{
					alt61 = 2;
					}
					break;
				case LIKE:
					{
					alt61 = 3;
					}
					break;
				case MEMBER:
					{
					alt61 = 4;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 61, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(61); }
				switch (alt61)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:425:4: (i= IN ^ inList )
					{
					DebugLocation(425, 4);
					// Hql.g:425:4: (i= IN ^ inList )
					DebugEnterAlt(1);
					// Hql.g:425:5: i= IN ^ inList
					{
					DebugLocation(425, 6);
					i=(IToken)Match(input,IN,Follow._IN_in_relationalExpression2135); 
					i_tree = (IASTNode)adaptor.Create(i);
					root_0 = (IASTNode)adaptor.BecomeRoot(i_tree, root_0);
					DebugLocation(425, 11);

										i.Type = (n == null) ? IN : NOT_IN;
										i.Text = (n == null) ? "in" : "not in";
									
					DebugLocation(429, 5);
					PushFollow(Follow._inList_in_relationalExpression2144);
					inList172=inList();
					PopFollow();

					adaptor.AddChild(root_0, inList172.Tree);

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:430:6: (b= BETWEEN ^ betweenList )
					{
					DebugLocation(430, 6);
					// Hql.g:430:6: (b= BETWEEN ^ betweenList )
					DebugEnterAlt(1);
					// Hql.g:430:7: b= BETWEEN ^ betweenList
					{
					DebugLocation(430, 8);
					b=(IToken)Match(input,BETWEEN,Follow._BETWEEN_in_relationalExpression2155); 
					b_tree = (IASTNode)adaptor.Create(b);
					root_0 = (IASTNode)adaptor.BecomeRoot(b_tree, root_0);
					DebugLocation(430, 18);

										b.Type = (n == null) ? BETWEEN : NOT_BETWEEN;
										b.Text = (n == null) ? "between" : "not between";
									
					DebugLocation(434, 5);
					PushFollow(Follow._betweenList_in_relationalExpression2164);
					betweenList173=betweenList();
					PopFollow();

					adaptor.AddChild(root_0, betweenList173.Tree);

					}


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:435:6: (l= LIKE ^ concatenation likeEscape )
					{
					DebugLocation(435, 6);
					// Hql.g:435:6: (l= LIKE ^ concatenation likeEscape )
					DebugEnterAlt(1);
					// Hql.g:435:7: l= LIKE ^ concatenation likeEscape
					{
					DebugLocation(435, 8);
					l=(IToken)Match(input,LIKE,Follow._LIKE_in_relationalExpression2176); 
					l_tree = (IASTNode)adaptor.Create(l);
					root_0 = (IASTNode)adaptor.BecomeRoot(l_tree, root_0);
					DebugLocation(435, 15);

										l.Type = (n == null) ? LIKE : NOT_LIKE;
										l.Text = (n == null) ? "like" : "not like";
									
					DebugLocation(439, 5);
					PushFollow(Follow._concatenation_in_relationalExpression2185);
					concatenation174=concatenation();
					PopFollow();

					adaptor.AddChild(root_0, concatenation174.Tree);
					DebugLocation(439, 19);
					PushFollow(Follow._likeEscape_in_relationalExpression2187);
					likeEscape175=likeEscape();
					PopFollow();

					adaptor.AddChild(root_0, likeEscape175.Tree);

					}


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Hql.g:440:6: ( MEMBER ! ( OF !)? p= path !)
					{
					DebugLocation(440, 6);
					// Hql.g:440:6: ( MEMBER ! ( OF !)? p= path !)
					DebugEnterAlt(1);
					// Hql.g:440:7: MEMBER ! ( OF !)? p= path !
					{
					DebugLocation(440, 13);
					MEMBER176=(IToken)Match(input,MEMBER,Follow._MEMBER_in_relationalExpression2196); 
					DebugLocation(440, 15);
					// Hql.g:440:15: ( OF !)?
					int alt60=2;
					try { DebugEnterSubRule(60);
					try { DebugEnterDecision(60, false);
					int LA60_1 = input.LA(1);

					if ((LA60_1==OF))
					{
						alt60 = 1;
					}
					} finally { DebugExitDecision(60); }
					switch (alt60)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:440:16: OF !
						{
						DebugLocation(440, 18);
						OF177=(IToken)Match(input,OF,Follow._OF_in_relationalExpression2200); 

						}
						break;

					}
					} finally { DebugExitSubRule(60); }

					DebugLocation(440, 23);
					PushFollow(Follow._path_in_relationalExpression2207);
					p=path();
					PopFollow();

					DebugLocation(440, 30);

									root_0 = ProcessMemberOf(n,(p!=null?((IASTNode)p.Tree):default(IASTNode)), root_0);
								  

					}


					}
					break;

				}
				} finally { DebugExitSubRule(61); }


				}
				break;

			}
			} finally { DebugExitSubRule(62); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 47);
			LeaveRule("relationalExpression", 47);
			LeaveRule_relationalExpression();
		}
		DebugLocation(445, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_likeEscape();
	partial void LeaveRule_likeEscape();
	// $ANTLR start "likeEscape"
	// Hql.g:447:1: likeEscape : ( ESCAPE ^ concatenation )? ;
	[GrammarRule("likeEscape")]
	private AstParserRuleReturnScope<IASTNode, IToken> likeEscape()
	{
		EnterRule_likeEscape();
		EnterRule("likeEscape", 48);
		TraceIn("likeEscape", 48);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken ESCAPE178 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> concatenation179 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode ESCAPE178_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "likeEscape");
		DebugLocation(447, 1);
		try
		{
			// Hql.g:448:2: ( ( ESCAPE ^ concatenation )? )
			DebugEnterAlt(1);
			// Hql.g:448:4: ( ESCAPE ^ concatenation )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(448, 4);
			// Hql.g:448:4: ( ESCAPE ^ concatenation )?
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			int LA63_1 = input.LA(1);

			if ((LA63_1==ESCAPE))
			{
				alt63 = 1;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:448:5: ESCAPE ^ concatenation
				{
				DebugLocation(448, 11);
				ESCAPE178=(IToken)Match(input,ESCAPE,Follow._ESCAPE_in_likeEscape2234); 
				ESCAPE178_tree = (IASTNode)adaptor.Create(ESCAPE178);
				root_0 = (IASTNode)adaptor.BecomeRoot(ESCAPE178_tree, root_0);
				DebugLocation(448, 13);
				PushFollow(Follow._concatenation_in_likeEscape2237);
				concatenation179=concatenation();
				PopFollow();

				adaptor.AddChild(root_0, concatenation179.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(63); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("likeEscape", 48);
			LeaveRule("likeEscape", 48);
			LeaveRule_likeEscape();
		}
		DebugLocation(449, 1);
		} finally { DebugExitRule(GrammarFileName, "likeEscape"); }
		return retval;

	}
	// $ANTLR end "likeEscape"

	partial void EnterRule_inList();
	partial void LeaveRule_inList();
	// $ANTLR start "inList"
	// Hql.g:451:1: inList : compoundExpr -> ^( IN_LIST[\"inList\"] compoundExpr ) ;
	[GrammarRule("inList")]
	private AstParserRuleReturnScope<IASTNode, IToken> inList()
	{
		EnterRule_inList();
		EnterRule("inList", 49);
		TraceIn("inList", 49);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> compoundExpr180 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_compoundExpr=new RewriteRuleSubtreeStream(adaptor,"rule compoundExpr");
		try { DebugEnterRule(GrammarFileName, "inList");
		DebugLocation(451, 1);
		try
		{
			// Hql.g:452:2: ( compoundExpr -> ^( IN_LIST[\"inList\"] compoundExpr ) )
			DebugEnterAlt(1);
			// Hql.g:452:4: compoundExpr
			{
			DebugLocation(452, 4);
			PushFollow(Follow._compoundExpr_in_inList2250);
			compoundExpr180=compoundExpr();
			PopFollow();

			stream_compoundExpr.Add(compoundExpr180.Tree);


			{
			// AST REWRITE
			// elements: compoundExpr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 453:2: -> ^( IN_LIST[\"inList\"] compoundExpr )
			{
				DebugLocation(453, 5);
				// Hql.g:453:5: ^( IN_LIST[\"inList\"] compoundExpr )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(453, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(IN_LIST, "inList"), root_1);

				DebugLocation(453, 25);
				adaptor.AddChild(root_1, stream_compoundExpr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inList", 49);
			LeaveRule("inList", 49);
			LeaveRule_inList();
		}
		DebugLocation(454, 1);
		} finally { DebugExitRule(GrammarFileName, "inList"); }
		return retval;

	}
	// $ANTLR end "inList"

	partial void EnterRule_betweenList();
	partial void LeaveRule_betweenList();
	// $ANTLR start "betweenList"
	// Hql.g:456:1: betweenList : concatenation AND ! concatenation ;
	[GrammarRule("betweenList")]
	private AstParserRuleReturnScope<IASTNode, IToken> betweenList()
	{
		EnterRule_betweenList();
		EnterRule("betweenList", 50);
		TraceIn("betweenList", 50);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken AND182 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> concatenation181 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> concatenation183 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode AND182_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "betweenList");
		DebugLocation(456, 1);
		try
		{
			// Hql.g:457:2: ( concatenation AND ! concatenation )
			DebugEnterAlt(1);
			// Hql.g:457:4: concatenation AND ! concatenation
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(457, 4);
			PushFollow(Follow._concatenation_in_betweenList2271);
			concatenation181=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation181.Tree);
			DebugLocation(457, 21);
			AND182=(IToken)Match(input,AND,Follow._AND_in_betweenList2273); 
			DebugLocation(457, 23);
			PushFollow(Follow._concatenation_in_betweenList2276);
			concatenation183=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation183.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("betweenList", 50);
			LeaveRule("betweenList", 50);
			LeaveRule_betweenList();
		}
		DebugLocation(458, 1);
		} finally { DebugExitRule(GrammarFileName, "betweenList"); }
		return retval;

	}
	// $ANTLR end "betweenList"

	partial void EnterRule_concatenation();
	partial void LeaveRule_concatenation();
	// $ANTLR start "concatenation"
	// Hql.g:461:1: concatenation : a= bitwiseNotExpression (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )? ;
	[GrammarRule("concatenation")]
	private AstParserRuleReturnScope<IASTNode, IToken> concatenation()
	{
		EnterRule_concatenation();
		EnterRule("concatenation", 51);
		TraceIn("concatenation", 51);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken c = default(IToken);
		IToken CONCAT185 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> a = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression184 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression186 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode c_tree = default(IASTNode);
		IASTNode CONCAT185_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "concatenation");
		DebugLocation(461, 1);
		try
		{
			// Hql.g:472:2: (a= bitwiseNotExpression (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )? )
			DebugEnterAlt(1);
			// Hql.g:472:4: a= bitwiseNotExpression (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(472, 5);
			PushFollow(Follow._bitwiseNotExpression_in_concatenation2295);
			a=bitwiseNotExpression();
			PopFollow();

			adaptor.AddChild(root_0, a.Tree);
			DebugLocation(473, 2);
			// Hql.g:473:2: (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )?
			int alt65=2;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, false);
			int LA65_1 = input.LA(1);

			if ((LA65_1==CONCAT))
			{
				alt65 = 1;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:473:4: c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )*
				{
				DebugLocation(473, 5);
				c=(IToken)Match(input,CONCAT,Follow._CONCAT_in_concatenation2303); 
				c_tree = (IASTNode)adaptor.Create(c);
				root_0 = (IASTNode)adaptor.BecomeRoot(c_tree, root_0);
				DebugLocation(473, 14);
				 c.Type = EXPR_LIST; c.Text = "concatList"; 
				DebugLocation(474, 4);
				PushFollow(Follow._bitwiseNotExpression_in_concatenation2312);
				bitwiseNotExpression184=bitwiseNotExpression();
				PopFollow();

				adaptor.AddChild(root_0, bitwiseNotExpression184.Tree);
				DebugLocation(475, 4);
				// Hql.g:475:4: ( CONCAT ! bitwiseNotExpression )*
				try { DebugEnterSubRule(64);
				while (true)
				{
					int alt64=2;
					try { DebugEnterDecision(64, false);
					int LA64_1 = input.LA(1);

					if ((LA64_1==CONCAT))
					{
						alt64 = 1;
					}


					} finally { DebugExitDecision(64); }
					switch ( alt64 )
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:475:6: CONCAT ! bitwiseNotExpression
						{
						DebugLocation(475, 12);
						CONCAT185=(IToken)Match(input,CONCAT,Follow._CONCAT_in_concatenation2319); 
						DebugLocation(475, 14);
						PushFollow(Follow._bitwiseNotExpression_in_concatenation2322);
						bitwiseNotExpression186=bitwiseNotExpression();
						PopFollow();

						adaptor.AddChild(root_0, bitwiseNotExpression186.Tree);

						}
						break;

					default:
						goto loop64;
					}
				}

				loop64:
					;

				} finally { DebugExitSubRule(64); }


				}
				break;

			}
			} finally { DebugExitSubRule(65); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);


			   if (c != null)
			   {
			      IASTNode mc = (IASTNode) adaptor.Create(METHOD_CALL, "||");
			      IASTNode concat = (IASTNode) adaptor.Create(IDENT, "concat");
			      mc.AddChild(concat);
			      mc.AddChild((IASTNode) retval.Tree);
			      retval.Tree = mc;
			   }

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concatenation", 51);
			LeaveRule("concatenation", 51);
			LeaveRule_concatenation();
		}
		DebugLocation(477, 1);
		} finally { DebugExitRule(GrammarFileName, "concatenation"); }
		return retval;

	}
	// $ANTLR end "concatenation"

	partial void EnterRule_bitwiseNotExpression();
	partial void LeaveRule_bitwiseNotExpression();
	// $ANTLR start "bitwiseNotExpression"
	// Hql.g:480:1: bitwiseNotExpression : ( ( BNOT ^ bitwiseOrExpression ) | bitwiseOrExpression );
	[GrammarRule("bitwiseNotExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression()
	{
		EnterRule_bitwiseNotExpression();
		EnterRule("bitwiseNotExpression", 52);
		TraceIn("bitwiseNotExpression", 52);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken BNOT187 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseOrExpression188 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseOrExpression189 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode BNOT187_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "bitwiseNotExpression");
		DebugLocation(480, 1);
		try
		{
			// Hql.g:481:2: ( ( BNOT ^ bitwiseOrExpression ) | bitwiseOrExpression )
			int alt66=2;
			try { DebugEnterDecision(66, false);
			int LA66_1 = input.LA(1);

			if ((LA66_1==BNOT))
			{
				alt66 = 1;
			}
			else if ((LA66_1==ALL||LA66_1==ANY||LA66_1==AVG||LA66_1==CASE||LA66_1==COLON||LA66_1==COUNT||LA66_1==ELEMENTS||LA66_1==EMPTY||LA66_1==EXISTS||LA66_1==FALSE||LA66_1==IDENT||LA66_1==INDICES||LA66_1==MAX||(LA66_1>=MIN && LA66_1<=MINUS)||(LA66_1>=NULL && LA66_1<=NUM_LONG)||LA66_1==OPEN||(LA66_1>=PARAM && LA66_1<=PLUS)||LA66_1==QUOTED_String||LA66_1==SOME||LA66_1==SUM||LA66_1==TRUE))
			{
				alt66 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 66, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:481:4: ( BNOT ^ bitwiseOrExpression )
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(481, 4);
				// Hql.g:481:4: ( BNOT ^ bitwiseOrExpression )
				DebugEnterAlt(1);
				// Hql.g:481:5: BNOT ^ bitwiseOrExpression
				{
				DebugLocation(481, 9);
				BNOT187=(IToken)Match(input,BNOT,Follow._BNOT_in_bitwiseNotExpression2346); 
				BNOT187_tree = (IASTNode)adaptor.Create(BNOT187);
				root_0 = (IASTNode)adaptor.BecomeRoot(BNOT187_tree, root_0);
				DebugLocation(481, 11);
				PushFollow(Follow._bitwiseOrExpression_in_bitwiseNotExpression2349);
				bitwiseOrExpression188=bitwiseOrExpression();
				PopFollow();

				adaptor.AddChild(root_0, bitwiseOrExpression188.Tree);

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:482:4: bitwiseOrExpression
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(482, 4);
				PushFollow(Follow._bitwiseOrExpression_in_bitwiseNotExpression2355);
				bitwiseOrExpression189=bitwiseOrExpression();
				PopFollow();

				adaptor.AddChild(root_0, bitwiseOrExpression189.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseNotExpression", 52);
			LeaveRule("bitwiseNotExpression", 52);
			LeaveRule_bitwiseNotExpression();
		}
		DebugLocation(483, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseNotExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseNotExpression"

	partial void EnterRule_bitwiseOrExpression();
	partial void LeaveRule_bitwiseOrExpression();
	// $ANTLR start "bitwiseOrExpression"
	// Hql.g:485:1: bitwiseOrExpression : bitwiseXOrExpression ( BOR ^ bitwiseXOrExpression )* ;
	[GrammarRule("bitwiseOrExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseOrExpression()
	{
		EnterRule_bitwiseOrExpression();
		EnterRule("bitwiseOrExpression", 53);
		TraceIn("bitwiseOrExpression", 53);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken BOR191 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseXOrExpression190 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseXOrExpression192 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode BOR191_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "bitwiseOrExpression");
		DebugLocation(485, 1);
		try
		{
			// Hql.g:486:2: ( bitwiseXOrExpression ( BOR ^ bitwiseXOrExpression )* )
			DebugEnterAlt(1);
			// Hql.g:486:4: bitwiseXOrExpression ( BOR ^ bitwiseXOrExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(486, 4);
			PushFollow(Follow._bitwiseXOrExpression_in_bitwiseOrExpression2367);
			bitwiseXOrExpression190=bitwiseXOrExpression();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseXOrExpression190.Tree);
			DebugLocation(486, 25);
			// Hql.g:486:25: ( BOR ^ bitwiseXOrExpression )*
			try { DebugEnterSubRule(67);
			while (true)
			{
				int alt67=2;
				try { DebugEnterDecision(67, false);
				int LA67_1 = input.LA(1);

				if ((LA67_1==BOR))
				{
					alt67 = 1;
				}


				} finally { DebugExitDecision(67); }
				switch ( alt67 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:486:26: BOR ^ bitwiseXOrExpression
					{
					DebugLocation(486, 29);
					BOR191=(IToken)Match(input,BOR,Follow._BOR_in_bitwiseOrExpression2370); 
					BOR191_tree = (IASTNode)adaptor.Create(BOR191);
					root_0 = (IASTNode)adaptor.BecomeRoot(BOR191_tree, root_0);
					DebugLocation(486, 31);
					PushFollow(Follow._bitwiseXOrExpression_in_bitwiseOrExpression2373);
					bitwiseXOrExpression192=bitwiseXOrExpression();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseXOrExpression192.Tree);

					}
					break;

				default:
					goto loop67;
				}
			}

			loop67:
				;

			} finally { DebugExitSubRule(67); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseOrExpression", 53);
			LeaveRule("bitwiseOrExpression", 53);
			LeaveRule_bitwiseOrExpression();
		}
		DebugLocation(487, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseOrExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseOrExpression"

	partial void EnterRule_bitwiseXOrExpression();
	partial void LeaveRule_bitwiseXOrExpression();
	// $ANTLR start "bitwiseXOrExpression"
	// Hql.g:489:1: bitwiseXOrExpression : bitwiseAndExpression ( BXOR ^ bitwiseAndExpression )* ;
	[GrammarRule("bitwiseXOrExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseXOrExpression()
	{
		EnterRule_bitwiseXOrExpression();
		EnterRule("bitwiseXOrExpression", 54);
		TraceIn("bitwiseXOrExpression", 54);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken BXOR194 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseAndExpression193 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseAndExpression195 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode BXOR194_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "bitwiseXOrExpression");
		DebugLocation(489, 1);
		try
		{
			// Hql.g:490:2: ( bitwiseAndExpression ( BXOR ^ bitwiseAndExpression )* )
			DebugEnterAlt(1);
			// Hql.g:490:4: bitwiseAndExpression ( BXOR ^ bitwiseAndExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(490, 4);
			PushFollow(Follow._bitwiseAndExpression_in_bitwiseXOrExpression2387);
			bitwiseAndExpression193=bitwiseAndExpression();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseAndExpression193.Tree);
			DebugLocation(490, 25);
			// Hql.g:490:25: ( BXOR ^ bitwiseAndExpression )*
			try { DebugEnterSubRule(68);
			while (true)
			{
				int alt68=2;
				try { DebugEnterDecision(68, false);
				int LA68_1 = input.LA(1);

				if ((LA68_1==BXOR))
				{
					alt68 = 1;
				}


				} finally { DebugExitDecision(68); }
				switch ( alt68 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:490:26: BXOR ^ bitwiseAndExpression
					{
					DebugLocation(490, 30);
					BXOR194=(IToken)Match(input,BXOR,Follow._BXOR_in_bitwiseXOrExpression2390); 
					BXOR194_tree = (IASTNode)adaptor.Create(BXOR194);
					root_0 = (IASTNode)adaptor.BecomeRoot(BXOR194_tree, root_0);
					DebugLocation(490, 32);
					PushFollow(Follow._bitwiseAndExpression_in_bitwiseXOrExpression2393);
					bitwiseAndExpression195=bitwiseAndExpression();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseAndExpression195.Tree);

					}
					break;

				default:
					goto loop68;
				}
			}

			loop68:
				;

			} finally { DebugExitSubRule(68); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXOrExpression", 54);
			LeaveRule("bitwiseXOrExpression", 54);
			LeaveRule_bitwiseXOrExpression();
		}
		DebugLocation(491, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXOrExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXOrExpression"

	partial void EnterRule_bitwiseAndExpression();
	partial void LeaveRule_bitwiseAndExpression();
	// $ANTLR start "bitwiseAndExpression"
	// Hql.g:493:1: bitwiseAndExpression : additiveExpression ( BAND ^ additiveExpression )* ;
	[GrammarRule("bitwiseAndExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseAndExpression()
	{
		EnterRule_bitwiseAndExpression();
		EnterRule("bitwiseAndExpression", 55);
		TraceIn("bitwiseAndExpression", 55);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken BAND197 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> additiveExpression196 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> additiveExpression198 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode BAND197_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "bitwiseAndExpression");
		DebugLocation(493, 1);
		try
		{
			// Hql.g:494:2: ( additiveExpression ( BAND ^ additiveExpression )* )
			DebugEnterAlt(1);
			// Hql.g:494:4: additiveExpression ( BAND ^ additiveExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(494, 4);
			PushFollow(Follow._additiveExpression_in_bitwiseAndExpression2407);
			additiveExpression196=additiveExpression();
			PopFollow();

			adaptor.AddChild(root_0, additiveExpression196.Tree);
			DebugLocation(494, 23);
			// Hql.g:494:23: ( BAND ^ additiveExpression )*
			try { DebugEnterSubRule(69);
			while (true)
			{
				int alt69=2;
				try { DebugEnterDecision(69, false);
				int LA69_1 = input.LA(1);

				if ((LA69_1==BAND))
				{
					alt69 = 1;
				}


				} finally { DebugExitDecision(69); }
				switch ( alt69 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:494:24: BAND ^ additiveExpression
					{
					DebugLocation(494, 28);
					BAND197=(IToken)Match(input,BAND,Follow._BAND_in_bitwiseAndExpression2410); 
					BAND197_tree = (IASTNode)adaptor.Create(BAND197);
					root_0 = (IASTNode)adaptor.BecomeRoot(BAND197_tree, root_0);
					DebugLocation(494, 30);
					PushFollow(Follow._additiveExpression_in_bitwiseAndExpression2413);
					additiveExpression198=additiveExpression();
					PopFollow();

					adaptor.AddChild(root_0, additiveExpression198.Tree);

					}
					break;

				default:
					goto loop69;
				}
			}

			loop69:
				;

			} finally { DebugExitSubRule(69); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseAndExpression", 55);
			LeaveRule("bitwiseAndExpression", 55);
			LeaveRule_bitwiseAndExpression();
		}
		DebugLocation(495, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseAndExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseAndExpression"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();
	// $ANTLR start "additiveExpression"
	// Hql.g:498:1: additiveExpression : multiplyExpression ( ( PLUS ^| MINUS ^) multiplyExpression )* ;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 56);
		TraceIn("additiveExpression", 56);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken PLUS200 = default(IToken);
		IToken MINUS201 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> multiplyExpression199 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> multiplyExpression202 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode PLUS200_tree = default(IASTNode);
		IASTNode MINUS201_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(498, 1);
		try
		{
			// Hql.g:499:2: ( multiplyExpression ( ( PLUS ^| MINUS ^) multiplyExpression )* )
			DebugEnterAlt(1);
			// Hql.g:499:4: multiplyExpression ( ( PLUS ^| MINUS ^) multiplyExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(499, 4);
			PushFollow(Follow._multiplyExpression_in_additiveExpression2427);
			multiplyExpression199=multiplyExpression();
			PopFollow();

			adaptor.AddChild(root_0, multiplyExpression199.Tree);
			DebugLocation(499, 23);
			// Hql.g:499:23: ( ( PLUS ^| MINUS ^) multiplyExpression )*
			try { DebugEnterSubRule(71);
			while (true)
			{
				int alt71=2;
				try { DebugEnterDecision(71, false);
				int LA71_1 = input.LA(1);

				if ((LA71_1==MINUS||LA71_1==PLUS))
				{
					alt71 = 1;
				}


				} finally { DebugExitDecision(71); }
				switch ( alt71 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:499:25: ( PLUS ^| MINUS ^) multiplyExpression
					{
					DebugLocation(499, 25);
					// Hql.g:499:25: ( PLUS ^| MINUS ^)
					int alt70=2;
					try { DebugEnterSubRule(70);
					try { DebugEnterDecision(70, false);
					int LA70_1 = input.LA(1);

					if ((LA70_1==PLUS))
					{
						alt70 = 1;
					}
					else if ((LA70_1==MINUS))
					{
						alt70 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 70, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(70); }
					switch (alt70)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:499:27: PLUS ^
						{
						DebugLocation(499, 31);
						PLUS200=(IToken)Match(input,PLUS,Follow._PLUS_in_additiveExpression2433); 
						PLUS200_tree = (IASTNode)adaptor.Create(PLUS200);
						root_0 = (IASTNode)adaptor.BecomeRoot(PLUS200_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Hql.g:499:35: MINUS ^
						{
						DebugLocation(499, 40);
						MINUS201=(IToken)Match(input,MINUS,Follow._MINUS_in_additiveExpression2438); 
						MINUS201_tree = (IASTNode)adaptor.Create(MINUS201);
						root_0 = (IASTNode)adaptor.BecomeRoot(MINUS201_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(70); }

					DebugLocation(499, 44);
					PushFollow(Follow._multiplyExpression_in_additiveExpression2443);
					multiplyExpression202=multiplyExpression();
					PopFollow();

					adaptor.AddChild(root_0, multiplyExpression202.Tree);

					}
					break;

				default:
					goto loop71;
				}
			}

			loop71:
				;

			} finally { DebugExitSubRule(71); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 56);
			LeaveRule("additiveExpression", 56);
			LeaveRule_additiveExpression();
		}
		DebugLocation(500, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_multiplyExpression();
	partial void LeaveRule_multiplyExpression();
	// $ANTLR start "multiplyExpression"
	// Hql.g:503:1: multiplyExpression : unaryExpression ( ( STAR ^| DIV ^) unaryExpression )* ;
	[GrammarRule("multiplyExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> multiplyExpression()
	{
		EnterRule_multiplyExpression();
		EnterRule("multiplyExpression", 57);
		TraceIn("multiplyExpression", 57);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken STAR204 = default(IToken);
		IToken DIV205 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> unaryExpression203 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> unaryExpression206 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode STAR204_tree = default(IASTNode);
		IASTNode DIV205_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "multiplyExpression");
		DebugLocation(503, 1);
		try
		{
			// Hql.g:504:2: ( unaryExpression ( ( STAR ^| DIV ^) unaryExpression )* )
			DebugEnterAlt(1);
			// Hql.g:504:4: unaryExpression ( ( STAR ^| DIV ^) unaryExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(504, 4);
			PushFollow(Follow._unaryExpression_in_multiplyExpression2458);
			unaryExpression203=unaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, unaryExpression203.Tree);
			DebugLocation(504, 20);
			// Hql.g:504:20: ( ( STAR ^| DIV ^) unaryExpression )*
			try { DebugEnterSubRule(73);
			while (true)
			{
				int alt73=2;
				try { DebugEnterDecision(73, false);
				int LA73_1 = input.LA(1);

				if ((LA73_1==DIV||LA73_1==STAR))
				{
					alt73 = 1;
				}


				} finally { DebugExitDecision(73); }
				switch ( alt73 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:504:22: ( STAR ^| DIV ^) unaryExpression
					{
					DebugLocation(504, 22);
					// Hql.g:504:22: ( STAR ^| DIV ^)
					int alt72=2;
					try { DebugEnterSubRule(72);
					try { DebugEnterDecision(72, false);
					int LA72_1 = input.LA(1);

					if ((LA72_1==STAR))
					{
						alt72 = 1;
					}
					else if ((LA72_1==DIV))
					{
						alt72 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 72, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(72); }
					switch (alt72)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:504:24: STAR ^
						{
						DebugLocation(504, 28);
						STAR204=(IToken)Match(input,STAR,Follow._STAR_in_multiplyExpression2464); 
						STAR204_tree = (IASTNode)adaptor.Create(STAR204);
						root_0 = (IASTNode)adaptor.BecomeRoot(STAR204_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Hql.g:504:32: DIV ^
						{
						DebugLocation(504, 35);
						DIV205=(IToken)Match(input,DIV,Follow._DIV_in_multiplyExpression2469); 
						DIV205_tree = (IASTNode)adaptor.Create(DIV205);
						root_0 = (IASTNode)adaptor.BecomeRoot(DIV205_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(72); }

					DebugLocation(504, 39);
					PushFollow(Follow._unaryExpression_in_multiplyExpression2474);
					unaryExpression206=unaryExpression();
					PopFollow();

					adaptor.AddChild(root_0, unaryExpression206.Tree);

					}
					break;

				default:
					goto loop73;
				}
			}

			loop73:
				;

			} finally { DebugExitSubRule(73); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplyExpression", 57);
			LeaveRule("multiplyExpression", 57);
			LeaveRule_multiplyExpression();
		}
		DebugLocation(505, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplyExpression"); }
		return retval;

	}
	// $ANTLR end "multiplyExpression"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// Hql.g:508:1: unaryExpression : (m= MINUS mu= unaryExpression -> ^( UNARY_MINUS[$m] $mu) |p= PLUS pu= unaryExpression -> ^( UNARY_PLUS[$p] $pu) | caseExpression | quantifiedExpression | atom );
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 58);
		TraceIn("unaryExpression", 58);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken m = default(IToken);
		IToken p = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> mu = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> pu = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> caseExpression207 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> quantifiedExpression208 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> atom209 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode m_tree = default(IASTNode);
		IASTNode p_tree = default(IASTNode);
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(508, 1);
		try
		{
			// Hql.g:509:2: (m= MINUS mu= unaryExpression -> ^( UNARY_MINUS[$m] $mu) |p= PLUS pu= unaryExpression -> ^( UNARY_PLUS[$p] $pu) | caseExpression | quantifiedExpression | atom )
			int alt74=5;
			try { DebugEnterDecision(74, false);
			switch (input.LA(1))
			{
			case MINUS:
				{
				alt74 = 1;
				}
				break;
			case PLUS:
				{
				alt74 = 2;
				}
				break;
			case CASE:
				{
				alt74 = 3;
				}
				break;
			case ALL:
			case ANY:
			case EXISTS:
			case SOME:
				{
				alt74 = 4;
				}
				break;
			case AVG:
			case COLON:
			case COUNT:
			case ELEMENTS:
			case EMPTY:
			case FALSE:
			case IDENT:
			case INDICES:
			case MAX:
			case MIN:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case OPEN:
			case PARAM:
			case QUOTED_String:
			case SUM:
			case TRUE:
				{
				alt74 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 74, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(74); }
			switch (alt74)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:509:4: m= MINUS mu= unaryExpression
				{
				DebugLocation(509, 5);
				m=(IToken)Match(input,MINUS,Follow._MINUS_in_unaryExpression2492);  
				stream_MINUS.Add(m);

				DebugLocation(509, 14);
				PushFollow(Follow._unaryExpression_in_unaryExpression2496);
				mu=unaryExpression();
				PopFollow();

				stream_unaryExpression.Add(mu.Tree);


				{
				// AST REWRITE
				// elements: mu
				// token labels: 
				// rule labels: mu, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_mu=new RewriteRuleSubtreeStream(adaptor,"rule mu",mu!=null?mu.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 509:31: -> ^( UNARY_MINUS[$m] $mu)
				{
					DebugLocation(509, 34);
					// Hql.g:509:34: ^( UNARY_MINUS[$m] $mu)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(509, 36);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(UNARY_MINUS, m), root_1);

					DebugLocation(509, 53);
					adaptor.AddChild(root_1, stream_mu.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:510:4: p= PLUS pu= unaryExpression
				{
				DebugLocation(510, 5);
				p=(IToken)Match(input,PLUS,Follow._PLUS_in_unaryExpression2513);  
				stream_PLUS.Add(p);

				DebugLocation(510, 13);
				PushFollow(Follow._unaryExpression_in_unaryExpression2517);
				pu=unaryExpression();
				PopFollow();

				stream_unaryExpression.Add(pu.Tree);


				{
				// AST REWRITE
				// elements: pu
				// token labels: 
				// rule labels: pu, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_pu=new RewriteRuleSubtreeStream(adaptor,"rule pu",pu!=null?pu.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 510:30: -> ^( UNARY_PLUS[$p] $pu)
				{
					DebugLocation(510, 33);
					// Hql.g:510:33: ^( UNARY_PLUS[$p] $pu)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(510, 35);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(UNARY_PLUS, p), root_1);

					DebugLocation(510, 51);
					adaptor.AddChild(root_1, stream_pu.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:511:4: caseExpression
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(511, 4);
				PushFollow(Follow._caseExpression_in_unaryExpression2532);
				caseExpression207=caseExpression();
				PopFollow();

				adaptor.AddChild(root_0, caseExpression207.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:512:4: quantifiedExpression
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(512, 4);
				PushFollow(Follow._quantifiedExpression_in_unaryExpression2537);
				quantifiedExpression208=quantifiedExpression();
				PopFollow();

				adaptor.AddChild(root_0, quantifiedExpression208.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Hql.g:513:4: atom
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(513, 4);
				PushFollow(Follow._atom_in_unaryExpression2542);
				atom209=atom();
				PopFollow();

				adaptor.AddChild(root_0, atom209.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 58);
			LeaveRule("unaryExpression", 58);
			LeaveRule_unaryExpression();
		}
		DebugLocation(514, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_caseExpression();
	partial void LeaveRule_caseExpression();
	// $ANTLR start "caseExpression"
	// Hql.g:516:1: caseExpression : ( CASE ( whenClause )+ ( elseClause )? END -> ^( CASE ( whenClause )+ ( elseClause )? ) | CASE unaryExpression ( altWhenClause )+ ( elseClause )? END -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? ) );
	[GrammarRule("caseExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> caseExpression()
	{
		EnterRule_caseExpression();
		EnterRule("caseExpression", 59);
		TraceIn("caseExpression", 59);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken CASE210 = default(IToken);
		IToken END213 = default(IToken);
		IToken CASE214 = default(IToken);
		IToken END218 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> whenClause211 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> elseClause212 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> unaryExpression215 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> altWhenClause216 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> elseClause217 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode CASE210_tree = default(IASTNode);
		IASTNode END213_tree = default(IASTNode);
		IASTNode CASE214_tree = default(IASTNode);
		IASTNode END218_tree = default(IASTNode);
		RewriteRuleITokenStream stream_CASE=new RewriteRuleITokenStream(adaptor,"token CASE");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_whenClause=new RewriteRuleSubtreeStream(adaptor,"rule whenClause");
		RewriteRuleSubtreeStream stream_elseClause=new RewriteRuleSubtreeStream(adaptor,"rule elseClause");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		RewriteRuleSubtreeStream stream_altWhenClause=new RewriteRuleSubtreeStream(adaptor,"rule altWhenClause");
		try { DebugEnterRule(GrammarFileName, "caseExpression");
		DebugLocation(516, 1);
		try
		{
			// Hql.g:517:2: ( CASE ( whenClause )+ ( elseClause )? END -> ^( CASE ( whenClause )+ ( elseClause )? ) | CASE unaryExpression ( altWhenClause )+ ( elseClause )? END -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? ) )
			int alt79=2;
			try { DebugEnterDecision(79, false);
			int LA79_1 = input.LA(1);

			if ((LA79_1==CASE))
			{
				int LA79_2 = input.LA(2);

				if ((LA79_2==WHEN))
				{
					alt79 = 1;
				}
				else if ((LA79_2==ALL||LA79_2==ANY||LA79_2==AVG||LA79_2==CASE||LA79_2==COLON||LA79_2==COUNT||LA79_2==ELEMENTS||LA79_2==EMPTY||LA79_2==EXISTS||LA79_2==FALSE||LA79_2==IDENT||LA79_2==INDICES||LA79_2==MAX||(LA79_2>=MIN && LA79_2<=MINUS)||(LA79_2>=NULL && LA79_2<=NUM_LONG)||LA79_2==OPEN||(LA79_2>=PARAM && LA79_2<=PLUS)||LA79_2==QUOTED_String||LA79_2==SOME||LA79_2==SUM||LA79_2==TRUE))
				{
					alt79 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 79, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 79, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(79); }
			switch (alt79)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:517:4: CASE ( whenClause )+ ( elseClause )? END
				{
				DebugLocation(517, 4);
				CASE210=(IToken)Match(input,CASE,Follow._CASE_in_caseExpression2554);  
				stream_CASE.Add(CASE210);

				DebugLocation(517, 9);
				// Hql.g:517:9: ( whenClause )+
				int cnt75=0;
				try { DebugEnterSubRule(75);
				while (true)
				{
					int alt75=2;
					try { DebugEnterDecision(75, false);
					int LA75_1 = input.LA(1);

					if ((LA75_1==WHEN))
					{
						alt75 = 1;
					}


					} finally { DebugExitDecision(75); }
					switch (alt75)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:517:10: whenClause
						{
						DebugLocation(517, 10);
						PushFollow(Follow._whenClause_in_caseExpression2557);
						whenClause211=whenClause();
						PopFollow();

						stream_whenClause.Add(whenClause211.Tree);

						}
						break;

					default:
						if (cnt75 >= 1)
							goto loop75;

						EarlyExitException eee75 = new EarlyExitException( 75, input );
						DebugRecognitionException(eee75);
						throw eee75;
					}
					cnt75++;
				}
				loop75:
					;

				} finally { DebugExitSubRule(75); }

				DebugLocation(517, 23);
				// Hql.g:517:23: ( elseClause )?
				int alt76=2;
				try { DebugEnterSubRule(76);
				try { DebugEnterDecision(76, false);
				int LA76_1 = input.LA(1);

				if ((LA76_1==ELSE))
				{
					alt76 = 1;
				}
				} finally { DebugExitDecision(76); }
				switch (alt76)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:517:24: elseClause
					{
					DebugLocation(517, 24);
					PushFollow(Follow._elseClause_in_caseExpression2562);
					elseClause212=elseClause();
					PopFollow();

					stream_elseClause.Add(elseClause212.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(76); }

				DebugLocation(517, 37);
				END213=(IToken)Match(input,END,Follow._END_in_caseExpression2566);  
				stream_END.Add(END213);



				{
				// AST REWRITE
				// elements: CASE, whenClause, elseClause
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 518:3: -> ^( CASE ( whenClause )+ ( elseClause )? )
				{
					DebugLocation(518, 6);
					// Hql.g:518:6: ^( CASE ( whenClause )+ ( elseClause )? )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(518, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_CASE.NextNode(), root_1);

					DebugLocation(518, 13);
					if (!(stream_whenClause.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_whenClause.HasNext )
					{
						DebugLocation(518, 13);
						adaptor.AddChild(root_1, stream_whenClause.NextTree());

					}
					stream_whenClause.Reset();
					DebugLocation(518, 25);
					// Hql.g:518:25: ( elseClause )?
					if (stream_elseClause.HasNext)
					{
						DebugLocation(518, 25);
						adaptor.AddChild(root_1, stream_elseClause.NextTree());

					}
					stream_elseClause.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:519:4: CASE unaryExpression ( altWhenClause )+ ( elseClause )? END
				{
				DebugLocation(519, 4);
				CASE214=(IToken)Match(input,CASE,Follow._CASE_in_caseExpression2586);  
				stream_CASE.Add(CASE214);

				DebugLocation(519, 9);
				PushFollow(Follow._unaryExpression_in_caseExpression2588);
				unaryExpression215=unaryExpression();
				PopFollow();

				stream_unaryExpression.Add(unaryExpression215.Tree);
				DebugLocation(519, 25);
				// Hql.g:519:25: ( altWhenClause )+
				int cnt77=0;
				try { DebugEnterSubRule(77);
				while (true)
				{
					int alt77=2;
					try { DebugEnterDecision(77, false);
					int LA77_1 = input.LA(1);

					if ((LA77_1==WHEN))
					{
						alt77 = 1;
					}


					} finally { DebugExitDecision(77); }
					switch (alt77)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:519:26: altWhenClause
						{
						DebugLocation(519, 26);
						PushFollow(Follow._altWhenClause_in_caseExpression2591);
						altWhenClause216=altWhenClause();
						PopFollow();

						stream_altWhenClause.Add(altWhenClause216.Tree);

						}
						break;

					default:
						if (cnt77 >= 1)
							goto loop77;

						EarlyExitException eee77 = new EarlyExitException( 77, input );
						DebugRecognitionException(eee77);
						throw eee77;
					}
					cnt77++;
				}
				loop77:
					;

				} finally { DebugExitSubRule(77); }

				DebugLocation(519, 42);
				// Hql.g:519:42: ( elseClause )?
				int alt78=2;
				try { DebugEnterSubRule(78);
				try { DebugEnterDecision(78, false);
				int LA78_1 = input.LA(1);

				if ((LA78_1==ELSE))
				{
					alt78 = 1;
				}
				} finally { DebugExitDecision(78); }
				switch (alt78)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:519:43: elseClause
					{
					DebugLocation(519, 43);
					PushFollow(Follow._elseClause_in_caseExpression2596);
					elseClause217=elseClause();
					PopFollow();

					stream_elseClause.Add(elseClause217.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(78); }

				DebugLocation(519, 56);
				END218=(IToken)Match(input,END,Follow._END_in_caseExpression2600);  
				stream_END.Add(END218);



				{
				// AST REWRITE
				// elements: unaryExpression, altWhenClause, elseClause
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 520:3: -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? )
				{
					DebugLocation(520, 6);
					// Hql.g:520:6: ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(520, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(CASE2, "CASE2"), root_1);

					DebugLocation(520, 14);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());
					DebugLocation(520, 30);
					if (!(stream_altWhenClause.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_altWhenClause.HasNext )
					{
						DebugLocation(520, 30);
						adaptor.AddChild(root_1, stream_altWhenClause.NextTree());

					}
					stream_altWhenClause.Reset();
					DebugLocation(520, 45);
					// Hql.g:520:45: ( elseClause )?
					if (stream_elseClause.HasNext)
					{
						DebugLocation(520, 45);
						adaptor.AddChild(root_1, stream_elseClause.NextTree());

					}
					stream_elseClause.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseExpression", 59);
			LeaveRule("caseExpression", 59);
			LeaveRule_caseExpression();
		}
		DebugLocation(521, 1);
		} finally { DebugExitRule(GrammarFileName, "caseExpression"); }
		return retval;

	}
	// $ANTLR end "caseExpression"

	partial void EnterRule_whenClause();
	partial void LeaveRule_whenClause();
	// $ANTLR start "whenClause"
	// Hql.g:523:1: whenClause : ( WHEN ^ logicalExpression THEN ! expression ) ;
	[GrammarRule("whenClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> whenClause()
	{
		EnterRule_whenClause();
		EnterRule("whenClause", 60);
		TraceIn("whenClause", 60);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken WHEN219 = default(IToken);
		IToken THEN221 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> logicalExpression220 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression222 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode WHEN219_tree = default(IASTNode);
		IASTNode THEN221_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "whenClause");
		DebugLocation(523, 1);
		try
		{
			// Hql.g:524:2: ( ( WHEN ^ logicalExpression THEN ! expression ) )
			DebugEnterAlt(1);
			// Hql.g:524:4: ( WHEN ^ logicalExpression THEN ! expression )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(524, 4);
			// Hql.g:524:4: ( WHEN ^ logicalExpression THEN ! expression )
			DebugEnterAlt(1);
			// Hql.g:524:5: WHEN ^ logicalExpression THEN ! expression
			{
			DebugLocation(524, 9);
			WHEN219=(IToken)Match(input,WHEN,Follow._WHEN_in_whenClause2629); 
			WHEN219_tree = (IASTNode)adaptor.Create(WHEN219);
			root_0 = (IASTNode)adaptor.BecomeRoot(WHEN219_tree, root_0);
			DebugLocation(524, 11);
			PushFollow(Follow._logicalExpression_in_whenClause2632);
			logicalExpression220=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression220.Tree);
			DebugLocation(524, 33);
			THEN221=(IToken)Match(input,THEN,Follow._THEN_in_whenClause2634); 
			DebugLocation(524, 35);
			PushFollow(Follow._expression_in_whenClause2637);
			expression222=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression222.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whenClause", 60);
			LeaveRule("whenClause", 60);
			LeaveRule_whenClause();
		}
		DebugLocation(525, 1);
		} finally { DebugExitRule(GrammarFileName, "whenClause"); }
		return retval;

	}
	// $ANTLR end "whenClause"

	partial void EnterRule_altWhenClause();
	partial void LeaveRule_altWhenClause();
	// $ANTLR start "altWhenClause"
	// Hql.g:527:1: altWhenClause : ( WHEN ^ unaryExpression THEN ! expression ) ;
	[GrammarRule("altWhenClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> altWhenClause()
	{
		EnterRule_altWhenClause();
		EnterRule("altWhenClause", 61);
		TraceIn("altWhenClause", 61);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken WHEN223 = default(IToken);
		IToken THEN225 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> unaryExpression224 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression226 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode WHEN223_tree = default(IASTNode);
		IASTNode THEN225_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "altWhenClause");
		DebugLocation(527, 1);
		try
		{
			// Hql.g:528:2: ( ( WHEN ^ unaryExpression THEN ! expression ) )
			DebugEnterAlt(1);
			// Hql.g:528:4: ( WHEN ^ unaryExpression THEN ! expression )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(528, 4);
			// Hql.g:528:4: ( WHEN ^ unaryExpression THEN ! expression )
			DebugEnterAlt(1);
			// Hql.g:528:5: WHEN ^ unaryExpression THEN ! expression
			{
			DebugLocation(528, 9);
			WHEN223=(IToken)Match(input,WHEN,Follow._WHEN_in_altWhenClause2651); 
			WHEN223_tree = (IASTNode)adaptor.Create(WHEN223);
			root_0 = (IASTNode)adaptor.BecomeRoot(WHEN223_tree, root_0);
			DebugLocation(528, 11);
			PushFollow(Follow._unaryExpression_in_altWhenClause2654);
			unaryExpression224=unaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, unaryExpression224.Tree);
			DebugLocation(528, 31);
			THEN225=(IToken)Match(input,THEN,Follow._THEN_in_altWhenClause2656); 
			DebugLocation(528, 33);
			PushFollow(Follow._expression_in_altWhenClause2659);
			expression226=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression226.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("altWhenClause", 61);
			LeaveRule("altWhenClause", 61);
			LeaveRule_altWhenClause();
		}
		DebugLocation(529, 1);
		} finally { DebugExitRule(GrammarFileName, "altWhenClause"); }
		return retval;

	}
	// $ANTLR end "altWhenClause"

	partial void EnterRule_elseClause();
	partial void LeaveRule_elseClause();
	// $ANTLR start "elseClause"
	// Hql.g:531:1: elseClause : ( ELSE ^ expression ) ;
	[GrammarRule("elseClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> elseClause()
	{
		EnterRule_elseClause();
		EnterRule("elseClause", 62);
		TraceIn("elseClause", 62);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken ELSE227 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> expression228 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode ELSE227_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "elseClause");
		DebugLocation(531, 1);
		try
		{
			// Hql.g:532:2: ( ( ELSE ^ expression ) )
			DebugEnterAlt(1);
			// Hql.g:532:4: ( ELSE ^ expression )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(532, 4);
			// Hql.g:532:4: ( ELSE ^ expression )
			DebugEnterAlt(1);
			// Hql.g:532:5: ELSE ^ expression
			{
			DebugLocation(532, 9);
			ELSE227=(IToken)Match(input,ELSE,Follow._ELSE_in_elseClause2673); 
			ELSE227_tree = (IASTNode)adaptor.Create(ELSE227);
			root_0 = (IASTNode)adaptor.BecomeRoot(ELSE227_tree, root_0);
			DebugLocation(532, 11);
			PushFollow(Follow._expression_in_elseClause2676);
			expression228=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression228.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elseClause", 62);
			LeaveRule("elseClause", 62);
			LeaveRule_elseClause();
		}
		DebugLocation(533, 1);
		} finally { DebugExitRule(GrammarFileName, "elseClause"); }
		return retval;

	}
	// $ANTLR end "elseClause"

	partial void EnterRule_quantifiedExpression();
	partial void LeaveRule_quantifiedExpression();
	// $ANTLR start "quantifiedExpression"
	// Hql.g:535:1: quantifiedExpression : ( SOME ^| EXISTS ^| ALL ^| ANY ^) ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) ) ;
	[GrammarRule("quantifiedExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> quantifiedExpression()
	{
		EnterRule_quantifiedExpression();
		EnterRule("quantifiedExpression", 63);
		TraceIn("quantifiedExpression", 63);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken SOME229 = default(IToken);
		IToken EXISTS230 = default(IToken);
		IToken ALL231 = default(IToken);
		IToken ANY232 = default(IToken);
		IToken OPEN235 = default(IToken);
		IToken CLOSE237 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identifier233 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> collectionExpr234 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> subQuery236 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode SOME229_tree = default(IASTNode);
		IASTNode EXISTS230_tree = default(IASTNode);
		IASTNode ALL231_tree = default(IASTNode);
		IASTNode ANY232_tree = default(IASTNode);
		IASTNode OPEN235_tree = default(IASTNode);
		IASTNode CLOSE237_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "quantifiedExpression");
		DebugLocation(535, 1);
		try
		{
			// Hql.g:536:2: ( ( SOME ^| EXISTS ^| ALL ^| ANY ^) ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) ) )
			DebugEnterAlt(1);
			// Hql.g:536:4: ( SOME ^| EXISTS ^| ALL ^| ANY ^) ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(536, 4);
			// Hql.g:536:4: ( SOME ^| EXISTS ^| ALL ^| ANY ^)
			int alt80=4;
			try { DebugEnterSubRule(80);
			try { DebugEnterDecision(80, false);
			switch (input.LA(1))
			{
			case SOME:
				{
				alt80 = 1;
				}
				break;
			case EXISTS:
				{
				alt80 = 2;
				}
				break;
			case ALL:
				{
				alt80 = 3;
				}
				break;
			case ANY:
				{
				alt80 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 80, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(80); }
			switch (alt80)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:536:6: SOME ^
				{
				DebugLocation(536, 10);
				SOME229=(IToken)Match(input,SOME,Follow._SOME_in_quantifiedExpression2691); 
				SOME229_tree = (IASTNode)adaptor.Create(SOME229);
				root_0 = (IASTNode)adaptor.BecomeRoot(SOME229_tree, root_0);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:536:14: EXISTS ^
				{
				DebugLocation(536, 20);
				EXISTS230=(IToken)Match(input,EXISTS,Follow._EXISTS_in_quantifiedExpression2696); 
				EXISTS230_tree = (IASTNode)adaptor.Create(EXISTS230);
				root_0 = (IASTNode)adaptor.BecomeRoot(EXISTS230_tree, root_0);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:536:24: ALL ^
				{
				DebugLocation(536, 27);
				ALL231=(IToken)Match(input,ALL,Follow._ALL_in_quantifiedExpression2701); 
				ALL231_tree = (IASTNode)adaptor.Create(ALL231);
				root_0 = (IASTNode)adaptor.BecomeRoot(ALL231_tree, root_0);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:536:31: ANY ^
				{
				DebugLocation(536, 34);
				ANY232=(IToken)Match(input,ANY,Follow._ANY_in_quantifiedExpression2706); 
				ANY232_tree = (IASTNode)adaptor.Create(ANY232);
				root_0 = (IASTNode)adaptor.BecomeRoot(ANY232_tree, root_0);

				}
				break;

			}
			} finally { DebugExitSubRule(80); }

			DebugLocation(537, 2);
			// Hql.g:537:2: ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) )
			int alt81=3;
			try { DebugEnterSubRule(81);
			try { DebugEnterDecision(81, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt81 = 1;
				}
				break;
			case ELEMENTS:
			case INDICES:
				{
				alt81 = 2;
				}
				break;
			case OPEN:
				{
				alt81 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 81, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(81); }
			switch (alt81)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:537:4: identifier
				{
				DebugLocation(537, 4);
				PushFollow(Follow._identifier_in_quantifiedExpression2715);
				identifier233=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier233.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:537:17: collectionExpr
				{
				DebugLocation(537, 17);
				PushFollow(Follow._collectionExpr_in_quantifiedExpression2719);
				collectionExpr234=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr234.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:537:34: ( OPEN ! ( subQuery ) CLOSE !)
				{
				DebugLocation(537, 34);
				// Hql.g:537:34: ( OPEN ! ( subQuery ) CLOSE !)
				DebugEnterAlt(1);
				// Hql.g:537:35: OPEN ! ( subQuery ) CLOSE !
				{
				DebugLocation(537, 39);
				OPEN235=(IToken)Match(input,OPEN,Follow._OPEN_in_quantifiedExpression2724); 
				DebugLocation(537, 41);
				// Hql.g:537:41: ( subQuery )
				DebugEnterAlt(1);
				// Hql.g:537:43: subQuery
				{
				DebugLocation(537, 43);
				PushFollow(Follow._subQuery_in_quantifiedExpression2729);
				subQuery236=subQuery();
				PopFollow();

				adaptor.AddChild(root_0, subQuery236.Tree);

				}

				DebugLocation(537, 59);
				CLOSE237=(IToken)Match(input,CLOSE,Follow._CLOSE_in_quantifiedExpression2733); 

				}


				}
				break;

			}
			} finally { DebugExitSubRule(81); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("quantifiedExpression", 63);
			LeaveRule("quantifiedExpression", 63);
			LeaveRule_quantifiedExpression();
		}
		DebugLocation(538, 1);
		} finally { DebugExitRule(GrammarFileName, "quantifiedExpression"); }
		return retval;

	}
	// $ANTLR end "quantifiedExpression"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Hql.g:543:1: atom : primaryExpression ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)* ;
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<IASTNode, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 64);
		TraceIn("atom", 64);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken op = default(IToken);
		IToken lb = default(IToken);
		IToken DOT239 = default(IToken);
		IToken CLOSE242 = default(IToken);
		IToken CLOSE_BRACKET244 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> primaryExpression238 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier240 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> exprList241 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression243 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode op_tree = default(IASTNode);
		IASTNode lb_tree = default(IASTNode);
		IASTNode DOT239_tree = default(IASTNode);
		IASTNode CLOSE242_tree = default(IASTNode);
		IASTNode CLOSE_BRACKET244_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(543, 1);
		try
		{
			// Hql.g:544:3: ( primaryExpression ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)* )
			DebugEnterAlt(1);
			// Hql.g:544:5: primaryExpression ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(544, 5);
			PushFollow(Follow._primaryExpression_in_atom2752);
			primaryExpression238=primaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, primaryExpression238.Tree);
			DebugLocation(545, 3);
			// Hql.g:545:3: ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)*
			try { DebugEnterSubRule(83);
			while (true)
			{
				int alt83=3;
				try { DebugEnterDecision(83, false);
				int LA83_1 = input.LA(1);

				if ((LA83_1==DOT))
				{
					alt83 = 1;
				}
				else if ((LA83_1==OPEN_BRACKET))
				{
					alt83 = 2;
				}


				} finally { DebugExitDecision(83); }
				switch ( alt83 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:546:4: DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )?
					{
					DebugLocation(546, 7);
					DOT239=(IToken)Match(input,DOT,Follow._DOT_in_atom2761); 
					DOT239_tree = (IASTNode)adaptor.Create(DOT239);
					root_0 = (IASTNode)adaptor.BecomeRoot(DOT239_tree, root_0);
					DebugLocation(546, 9);
					PushFollow(Follow._identifier_in_atom2764);
					identifier240=identifier();
					PopFollow();

					adaptor.AddChild(root_0, identifier240.Tree);
					DebugLocation(547, 5);
					// Hql.g:547:5: ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )?
					int alt82=2;
					try { DebugEnterSubRule(82);
					try { DebugEnterDecision(82, false);
					int LA82_1 = input.LA(1);

					if ((LA82_1==OPEN))
					{
						alt82 = 1;
					}
					} finally { DebugExitDecision(82); }
					switch (alt82)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:548:6: (op= OPEN ^ exprList CLOSE !)
						{
						DebugLocation(548, 6);
						// Hql.g:548:6: (op= OPEN ^ exprList CLOSE !)
						DebugEnterAlt(1);
						// Hql.g:548:8: op= OPEN ^ exprList CLOSE !
						{
						DebugLocation(548, 10);
						op=(IToken)Match(input,OPEN,Follow._OPEN_in_atom2792); 
						op_tree = (IASTNode)adaptor.Create(op);
						root_0 = (IASTNode)adaptor.BecomeRoot(op_tree, root_0);
						DebugLocation(548, 17);
						op.Type = METHOD_CALL; 
						DebugLocation(548, 44);
						PushFollow(Follow._exprList_in_atom2797);
						exprList241=exprList();
						PopFollow();

						adaptor.AddChild(root_0, exprList241.Tree);
						DebugLocation(548, 58);
						CLOSE242=(IToken)Match(input,CLOSE,Follow._CLOSE_in_atom2799); 

						}


						}
						break;

					}
					} finally { DebugExitSubRule(82); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:549:5: lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !
					{
					DebugLocation(549, 7);
					lb=(IToken)Match(input,OPEN_BRACKET,Follow._OPEN_BRACKET_in_atom2813); 
					lb_tree = (IASTNode)adaptor.Create(lb);
					root_0 = (IASTNode)adaptor.BecomeRoot(lb_tree, root_0);
					DebugLocation(549, 22);
					lb.Type = INDEX_OP; 
					DebugLocation(549, 46);
					PushFollow(Follow._expression_in_atom2818);
					expression243=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression243.Tree);
					DebugLocation(549, 70);
					CLOSE_BRACKET244=(IToken)Match(input,CLOSE_BRACKET,Follow._CLOSE_BRACKET_in_atom2820); 

					}
					break;

				default:
					goto loop83;
				}
			}

			loop83:
				;

			} finally { DebugExitSubRule(83); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 64);
			LeaveRule("atom", 64);
			LeaveRule_atom();
		}
		DebugLocation(551, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// Hql.g:554:1: primaryExpression : ( identPrimary ( options {greedy=true; } : DOT ^ 'class' )? | constant | COLON ^ identifier | OPEN ! ( expressionOrVector | subQuery ) CLOSE !| PARAM ^ ( NUM_INT )? );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 65);
		TraceIn("primaryExpression", 65);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken DOT246 = default(IToken);
		IToken string_literal247 = default(IToken);
		IToken COLON249 = default(IToken);
		IToken OPEN251 = default(IToken);
		IToken CLOSE254 = default(IToken);
		IToken PARAM255 = default(IToken);
		IToken NUM_INT256 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identPrimary245 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> constant248 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier250 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expressionOrVector252 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> subQuery253 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode DOT246_tree = default(IASTNode);
		IASTNode string_literal247_tree = default(IASTNode);
		IASTNode COLON249_tree = default(IASTNode);
		IASTNode OPEN251_tree = default(IASTNode);
		IASTNode CLOSE254_tree = default(IASTNode);
		IASTNode PARAM255_tree = default(IASTNode);
		IASTNode NUM_INT256_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(554, 1);
		try
		{
			// Hql.g:555:2: ( identPrimary ( options {greedy=true; } : DOT ^ 'class' )? | constant | COLON ^ identifier | OPEN ! ( expressionOrVector | subQuery ) CLOSE !| PARAM ^ ( NUM_INT )? )
			int alt87=5;
			try { DebugEnterDecision(87, false);
			switch (input.LA(1))
			{
			case AVG:
			case COUNT:
			case ELEMENTS:
			case IDENT:
			case INDICES:
			case MAX:
			case MIN:
			case SUM:
				{
				alt87 = 1;
				}
				break;
			case EMPTY:
			case FALSE:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case QUOTED_String:
			case TRUE:
				{
				alt87 = 2;
				}
				break;
			case COLON:
				{
				alt87 = 3;
				}
				break;
			case OPEN:
				{
				alt87 = 4;
				}
				break;
			case PARAM:
				{
				alt87 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 87, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(87); }
			switch (alt87)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:555:6: identPrimary ( options {greedy=true; } : DOT ^ 'class' )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(555, 6);
				PushFollow(Follow._identPrimary_in_primaryExpression2840);
				identPrimary245=identPrimary();
				PopFollow();

				adaptor.AddChild(root_0, identPrimary245.Tree);
				DebugLocation(555, 19);
				// Hql.g:555:19: ( options {greedy=true; } : DOT ^ 'class' )?
				int alt84=2;
				try { DebugEnterSubRule(84);
				try { DebugEnterDecision(84, false);
				int LA84_1 = input.LA(1);

				if ((LA84_1==DOT))
				{
					int LA84_2 = input.LA(2);

					if ((LA84_2==CLASS))
					{
						alt84 = 1;
					}
				}
				} finally { DebugExitDecision(84); }
				switch (alt84)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:555:46: DOT ^ 'class'
					{
					DebugLocation(555, 49);
					DOT246=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpression2853); 
					DOT246_tree = (IASTNode)adaptor.Create(DOT246);
					root_0 = (IASTNode)adaptor.BecomeRoot(DOT246_tree, root_0);
					DebugLocation(555, 51);
					string_literal247=(IToken)Match(input,CLASS,Follow._CLASS_in_primaryExpression2856); 
					string_literal247_tree = (IASTNode)adaptor.Create(string_literal247);
					adaptor.AddChild(root_0, string_literal247_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(84); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:556:6: constant
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(556, 6);
				PushFollow(Follow._constant_in_primaryExpression2866);
				constant248=constant();
				PopFollow();

				adaptor.AddChild(root_0, constant248.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:557:6: COLON ^ identifier
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(557, 11);
				COLON249=(IToken)Match(input,COLON,Follow._COLON_in_primaryExpression2873); 
				COLON249_tree = (IASTNode)adaptor.Create(COLON249);
				root_0 = (IASTNode)adaptor.BecomeRoot(COLON249_tree, root_0);
				DebugLocation(557, 13);
				PushFollow(Follow._identifier_in_primaryExpression2876);
				identifier250=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier250.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:559:6: OPEN ! ( expressionOrVector | subQuery ) CLOSE !
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(559, 10);
				OPEN251=(IToken)Match(input,OPEN,Follow._OPEN_in_primaryExpression2885); 
				DebugLocation(559, 12);
				// Hql.g:559:12: ( expressionOrVector | subQuery )
				int alt85=2;
				try { DebugEnterSubRule(85);
				try { DebugEnterDecision(85, false);
				int LA85_1 = input.LA(1);

				if ((LA85_1==ALL||LA85_1==ANY||LA85_1==AVG||LA85_1==BNOT||LA85_1==CASE||LA85_1==COLON||LA85_1==COUNT||LA85_1==ELEMENTS||LA85_1==EMPTY||LA85_1==EXISTS||LA85_1==FALSE||LA85_1==IDENT||LA85_1==INDICES||LA85_1==MAX||(LA85_1>=MIN && LA85_1<=MINUS)||LA85_1==NOT||(LA85_1>=NULL && LA85_1<=NUM_LONG)||LA85_1==OPEN||(LA85_1>=PARAM && LA85_1<=PLUS)||LA85_1==QUOTED_String||LA85_1==SOME||LA85_1==SUM||LA85_1==TRUE))
				{
					alt85 = 1;
				}
				else if ((LA85_1==EOF||LA85_1==CLOSE||LA85_1==FROM||LA85_1==GROUP||LA85_1==HAVING||LA85_1==ORDER||LA85_1==SELECT||LA85_1==SKIP||LA85_1==TAKE||LA85_1==UNION||LA85_1==WHERE))
				{
					alt85 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 85, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(85); }
				switch (alt85)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:559:13: expressionOrVector
					{
					DebugLocation(559, 13);
					PushFollow(Follow._expressionOrVector_in_primaryExpression2889);
					expressionOrVector252=expressionOrVector();
					PopFollow();

					adaptor.AddChild(root_0, expressionOrVector252.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:559:34: subQuery
					{
					DebugLocation(559, 34);
					PushFollow(Follow._subQuery_in_primaryExpression2893);
					subQuery253=subQuery();
					PopFollow();

					adaptor.AddChild(root_0, subQuery253.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(85); }

				DebugLocation(559, 49);
				CLOSE254=(IToken)Match(input,CLOSE,Follow._CLOSE_in_primaryExpression2896); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Hql.g:560:6: PARAM ^ ( NUM_INT )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(560, 11);
				PARAM255=(IToken)Match(input,PARAM,Follow._PARAM_in_primaryExpression2904); 
				PARAM255_tree = (IASTNode)adaptor.Create(PARAM255);
				root_0 = (IASTNode)adaptor.BecomeRoot(PARAM255_tree, root_0);
				DebugLocation(560, 13);
				// Hql.g:560:13: ( NUM_INT )?
				int alt86=2;
				try { DebugEnterSubRule(86);
				try { DebugEnterDecision(86, false);
				int LA86_1 = input.LA(1);

				if ((LA86_1==NUM_INT))
				{
					alt86 = 1;
				}
				} finally { DebugExitDecision(86); }
				switch (alt86)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:560:14: NUM_INT
					{
					DebugLocation(560, 14);
					NUM_INT256=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_primaryExpression2908); 
					NUM_INT256_tree = (IASTNode)adaptor.Create(NUM_INT256);
					adaptor.AddChild(root_0, NUM_INT256_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(86); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 65);
			LeaveRule("primaryExpression", 65);
			LeaveRule_primaryExpression();
		}
		DebugLocation(561, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_expressionOrVector();
	partial void LeaveRule_expressionOrVector();
	// $ANTLR start "expressionOrVector"
	// Hql.g:565:1: expressionOrVector : e= expression (v= vectorExpr )? -> {v != null}? ^( VECTOR_EXPR[\"{vector}\"] $e $v) -> $e;
	[GrammarRule("expressionOrVector")]
	private AstParserRuleReturnScope<IASTNode, IToken> expressionOrVector()
	{
		EnterRule_expressionOrVector();
		EnterRule("expressionOrVector", 66);
		TraceIn("expressionOrVector", 66);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> e = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> v = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_vectorExpr=new RewriteRuleSubtreeStream(adaptor,"rule vectorExpr");
		try { DebugEnterRule(GrammarFileName, "expressionOrVector");
		DebugLocation(565, 1);
		try
		{
			// Hql.g:566:2: (e= expression (v= vectorExpr )? -> {v != null}? ^( VECTOR_EXPR[\"{vector}\"] $e $v) -> $e)
			DebugEnterAlt(1);
			// Hql.g:566:4: e= expression (v= vectorExpr )?
			{
			DebugLocation(566, 5);
			PushFollow(Follow._expression_in_expressionOrVector2926);
			e=expression();
			PopFollow();

			stream_expression.Add(e.Tree);
			DebugLocation(566, 17);
			// Hql.g:566:17: (v= vectorExpr )?
			int alt88=2;
			try { DebugEnterSubRule(88);
			try { DebugEnterDecision(88, false);
			int LA88_1 = input.LA(1);

			if ((LA88_1==COMMA))
			{
				alt88 = 1;
			}
			} finally { DebugExitDecision(88); }
			switch (alt88)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:566:19: v= vectorExpr
				{
				DebugLocation(566, 20);
				PushFollow(Follow._vectorExpr_in_expressionOrVector2932);
				v=vectorExpr();
				PopFollow();

				stream_vectorExpr.Add(v.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(88); }



			{
			// AST REWRITE
			// elements: e, v, e
			// token labels: 
			// rule labels: e, v, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.Tree:null);
			RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 567:2: -> {v != null}? ^( VECTOR_EXPR[\"{vector}\"] $e $v)
			if (v != null)
			{
				DebugLocation(567, 18);
				// Hql.g:567:18: ^( VECTOR_EXPR[\"{vector}\"] $e $v)
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(567, 20);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(VECTOR_EXPR, "{vector}"), root_1);

				DebugLocation(567, 45);
				adaptor.AddChild(root_1, stream_e.NextTree());
				DebugLocation(567, 48);
				adaptor.AddChild(root_1, stream_v.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 568:2: -> $e
			{
				DebugLocation(568, 6);
				adaptor.AddChild(root_0, stream_e.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionOrVector", 66);
			LeaveRule("expressionOrVector", 66);
			LeaveRule_expressionOrVector();
		}
		DebugLocation(569, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionOrVector"); }
		return retval;

	}
	// $ANTLR end "expressionOrVector"

	partial void EnterRule_vectorExpr();
	partial void LeaveRule_vectorExpr();
	// $ANTLR start "vectorExpr"
	// Hql.g:571:1: vectorExpr : COMMA ! expression ( COMMA ! expression )* ;
	[GrammarRule("vectorExpr")]
	private AstParserRuleReturnScope<IASTNode, IToken> vectorExpr()
	{
		EnterRule_vectorExpr();
		EnterRule("vectorExpr", 67);
		TraceIn("vectorExpr", 67);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken COMMA257 = default(IToken);
		IToken COMMA259 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> expression258 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression260 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode COMMA257_tree = default(IASTNode);
		IASTNode COMMA259_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "vectorExpr");
		DebugLocation(571, 1);
		try
		{
			// Hql.g:572:2: ( COMMA ! expression ( COMMA ! expression )* )
			DebugEnterAlt(1);
			// Hql.g:572:4: COMMA ! expression ( COMMA ! expression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(572, 9);
			COMMA257=(IToken)Match(input,COMMA,Follow._COMMA_in_vectorExpr2969); 
			DebugLocation(572, 11);
			PushFollow(Follow._expression_in_vectorExpr2972);
			expression258=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression258.Tree);
			DebugLocation(572, 22);
			// Hql.g:572:22: ( COMMA ! expression )*
			try { DebugEnterSubRule(89);
			while (true)
			{
				int alt89=2;
				try { DebugEnterDecision(89, false);
				int LA89_1 = input.LA(1);

				if ((LA89_1==COMMA))
				{
					alt89 = 1;
				}


				} finally { DebugExitDecision(89); }
				switch ( alt89 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:572:23: COMMA ! expression
					{
					DebugLocation(572, 28);
					COMMA259=(IToken)Match(input,COMMA,Follow._COMMA_in_vectorExpr2975); 
					DebugLocation(572, 30);
					PushFollow(Follow._expression_in_vectorExpr2978);
					expression260=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression260.Tree);

					}
					break;

				default:
					goto loop89;
				}
			}

			loop89:
				;

			} finally { DebugExitSubRule(89); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("vectorExpr", 67);
			LeaveRule("vectorExpr", 67);
			LeaveRule_vectorExpr();
		}
		DebugLocation(573, 1);
		} finally { DebugExitRule(GrammarFileName, "vectorExpr"); }
		return retval;

	}
	// $ANTLR end "vectorExpr"

	partial void EnterRule_identPrimary();
	partial void LeaveRule_identPrimary();
	// $ANTLR start "identPrimary"
	// Hql.g:578:1: identPrimary : ( identifier ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )* ( (op= OPEN ^ exprList CLOSE !) )? | aggregate );
	[GrammarRule("identPrimary")]
	private AstParserRuleReturnScope<IASTNode, IToken> identPrimary()
	{
		EnterRule_identPrimary();
		EnterRule("identPrimary", 68);
		TraceIn("identPrimary", 68);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken o = default(IToken);
		IToken op = default(IToken);
		IToken DOT262 = default(IToken);
		IToken CLOSE265 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identifier261 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier263 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> exprList264 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> aggregate266 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode o_tree = default(IASTNode);
		IASTNode op_tree = default(IASTNode);
		IASTNode DOT262_tree = default(IASTNode);
		IASTNode CLOSE265_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "identPrimary");
		DebugLocation(578, 1);
		try
		{
			// Hql.g:579:2: ( identifier ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )* ( (op= OPEN ^ exprList CLOSE !) )? | aggregate )
			int alt93=2;
			try { DebugEnterDecision(93, false);
			int LA93_1 = input.LA(1);

			if ((LA93_1==IDENT))
			{
				alt93 = 1;
			}
			else if ((LA93_1==AVG||LA93_1==COUNT||LA93_1==ELEMENTS||LA93_1==INDICES||LA93_1==MAX||LA93_1==MIN||LA93_1==SUM))
			{
				alt93 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 93, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(93); }
			switch (alt93)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:579:4: identifier ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )* ( (op= OPEN ^ exprList CLOSE !) )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(579, 4);
				PushFollow(Follow._identifier_in_identPrimary2994);
				identifier261=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier261.Tree);
				DebugLocation(579, 15);
				 HandleDotIdent(); 
				DebugLocation(580, 4);
				// Hql.g:580:4: ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )*
				try { DebugEnterSubRule(91);
				while (true)
				{
					int alt91=2;
					try { DebugEnterDecision(91, false);
					int LA91_1 = input.LA(1);

					if ((LA91_1==DOT))
					{
						int LA91_2 = input.LA(2);

						if ((LA91_2==IDENT||LA91_2==OBJECT))
						{
							alt91 = 1;
						}


					}


					} finally { DebugExitDecision(91); }
					switch ( alt91 )
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:580:31: DOT ^ ( identifier |o= OBJECT )
						{
						DebugLocation(580, 34);
						DOT262=(IToken)Match(input,DOT,Follow._DOT_in_identPrimary3012); 
						DOT262_tree = (IASTNode)adaptor.Create(DOT262);
						root_0 = (IASTNode)adaptor.BecomeRoot(DOT262_tree, root_0);
						DebugLocation(580, 36);
						// Hql.g:580:36: ( identifier |o= OBJECT )
						int alt90=2;
						try { DebugEnterSubRule(90);
						try { DebugEnterDecision(90, false);
						int LA90_1 = input.LA(1);

						if ((LA90_1==IDENT))
						{
							alt90 = 1;
						}
						else if ((LA90_1==OBJECT))
						{
							alt90 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 90, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						} finally { DebugExitDecision(90); }
						switch (alt90)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:580:38: identifier
							{
							DebugLocation(580, 38);
							PushFollow(Follow._identifier_in_identPrimary3017);
							identifier263=identifier();
							PopFollow();

							adaptor.AddChild(root_0, identifier263.Tree);

							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Hql.g:580:51: o= OBJECT
							{
							DebugLocation(580, 52);
							o=(IToken)Match(input,OBJECT,Follow._OBJECT_in_identPrimary3023); 
							o_tree = (IASTNode)adaptor.Create(o);
							adaptor.AddChild(root_0, o_tree);
							DebugLocation(580, 60);
							 o.Type = IDENT; 

							}
							break;

						}
						} finally { DebugExitSubRule(90); }


						}
						break;

					default:
						goto loop91;
					}
				}

				loop91:
					;

				} finally { DebugExitSubRule(91); }

				DebugLocation(581, 4);
				// Hql.g:581:4: ( (op= OPEN ^ exprList CLOSE !) )?
				int alt92=2;
				try { DebugEnterSubRule(92);
				try { DebugEnterDecision(92, false);
				int LA92_1 = input.LA(1);

				if ((LA92_1==OPEN))
				{
					alt92 = 1;
				}
				} finally { DebugExitDecision(92); }
				switch (alt92)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:581:6: (op= OPEN ^ exprList CLOSE !)
					{
					DebugLocation(581, 6);
					// Hql.g:581:6: (op= OPEN ^ exprList CLOSE !)
					DebugEnterAlt(1);
					// Hql.g:581:8: op= OPEN ^ exprList CLOSE !
					{
					DebugLocation(581, 10);
					op=(IToken)Match(input,OPEN,Follow._OPEN_in_identPrimary3041); 
					op_tree = (IASTNode)adaptor.Create(op);
					root_0 = (IASTNode)adaptor.BecomeRoot(op_tree, root_0);
					DebugLocation(581, 17);
					 op.Type = METHOD_CALL;
					DebugLocation(581, 44);
					PushFollow(Follow._exprList_in_identPrimary3046);
					exprList264=exprList();
					PopFollow();

					adaptor.AddChild(root_0, exprList264.Tree);
					DebugLocation(581, 58);
					CLOSE265=(IToken)Match(input,CLOSE,Follow._CLOSE_in_identPrimary3048); 

					}


					}
					break;

				}
				} finally { DebugExitSubRule(92); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:584:4: aggregate
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(584, 4);
				PushFollow(Follow._aggregate_in_identPrimary3064);
				aggregate266=aggregate();
				PopFollow();

				adaptor.AddChild(root_0, aggregate266.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identPrimary", 68);
			LeaveRule("identPrimary", 68);
			LeaveRule_identPrimary();
		}
		DebugLocation(585, 1);
		} finally { DebugExitRule(GrammarFileName, "identPrimary"); }
		return retval;

	}
	// $ANTLR end "identPrimary"

	partial void EnterRule_aggregate();
	partial void LeaveRule_aggregate();
	// $ANTLR start "aggregate"
	// Hql.g:592:1: aggregate : ( (op= SUM |op= AVG |op= MAX |op= MIN ) OPEN additiveExpression CLOSE -> ^( AGGREGATE[$op] additiveExpression ) | COUNT OPEN (s= STAR |p= aggregateDistinctAll ) CLOSE -> {s == null}? ^( COUNT $p) -> ^( COUNT ^( ROW_STAR[\"*\"] ) ) | collectionExpr );
	[GrammarRule("aggregate")]
	private AstParserRuleReturnScope<IASTNode, IToken> aggregate()
	{
		EnterRule_aggregate();
		EnterRule("aggregate", 69);
		TraceIn("aggregate", 69);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken op = default(IToken);
		IToken s = default(IToken);
		IToken OPEN267 = default(IToken);
		IToken CLOSE269 = default(IToken);
		IToken COUNT270 = default(IToken);
		IToken OPEN271 = default(IToken);
		IToken CLOSE272 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> p = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> additiveExpression268 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> collectionExpr273 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode op_tree = default(IASTNode);
		IASTNode s_tree = default(IASTNode);
		IASTNode OPEN267_tree = default(IASTNode);
		IASTNode CLOSE269_tree = default(IASTNode);
		IASTNode COUNT270_tree = default(IASTNode);
		IASTNode OPEN271_tree = default(IASTNode);
		IASTNode CLOSE272_tree = default(IASTNode);
		RewriteRuleITokenStream stream_SUM=new RewriteRuleITokenStream(adaptor,"token SUM");
		RewriteRuleITokenStream stream_AVG=new RewriteRuleITokenStream(adaptor,"token AVG");
		RewriteRuleITokenStream stream_MAX=new RewriteRuleITokenStream(adaptor,"token MAX");
		RewriteRuleITokenStream stream_MIN=new RewriteRuleITokenStream(adaptor,"token MIN");
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
		RewriteRuleITokenStream stream_COUNT=new RewriteRuleITokenStream(adaptor,"token COUNT");
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
		RewriteRuleSubtreeStream stream_aggregateDistinctAll=new RewriteRuleSubtreeStream(adaptor,"rule aggregateDistinctAll");
		try { DebugEnterRule(GrammarFileName, "aggregate");
		DebugLocation(592, 1);
		try
		{
			// Hql.g:593:2: ( (op= SUM |op= AVG |op= MAX |op= MIN ) OPEN additiveExpression CLOSE -> ^( AGGREGATE[$op] additiveExpression ) | COUNT OPEN (s= STAR |p= aggregateDistinctAll ) CLOSE -> {s == null}? ^( COUNT $p) -> ^( COUNT ^( ROW_STAR[\"*\"] ) ) | collectionExpr )
			int alt96=3;
			try { DebugEnterDecision(96, false);
			switch (input.LA(1))
			{
			case AVG:
			case MAX:
			case MIN:
			case SUM:
				{
				alt96 = 1;
				}
				break;
			case COUNT:
				{
				alt96 = 2;
				}
				break;
			case ELEMENTS:
			case INDICES:
				{
				alt96 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 96, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(96); }
			switch (alt96)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:593:4: (op= SUM |op= AVG |op= MAX |op= MIN ) OPEN additiveExpression CLOSE
				{
				DebugLocation(593, 4);
				// Hql.g:593:4: (op= SUM |op= AVG |op= MAX |op= MIN )
				int alt94=4;
				try { DebugEnterSubRule(94);
				try { DebugEnterDecision(94, false);
				switch (input.LA(1))
				{
				case SUM:
					{
					alt94 = 1;
					}
					break;
				case AVG:
					{
					alt94 = 2;
					}
					break;
				case MAX:
					{
					alt94 = 3;
					}
					break;
				case MIN:
					{
					alt94 = 4;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 94, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(94); }
				switch (alt94)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:593:6: op= SUM
					{
					DebugLocation(593, 8);
					op=(IToken)Match(input,SUM,Follow._SUM_in_aggregate3085);  
					stream_SUM.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:593:15: op= AVG
					{
					DebugLocation(593, 17);
					op=(IToken)Match(input,AVG,Follow._AVG_in_aggregate3091);  
					stream_AVG.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:593:24: op= MAX
					{
					DebugLocation(593, 26);
					op=(IToken)Match(input,MAX,Follow._MAX_in_aggregate3097);  
					stream_MAX.Add(op);


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Hql.g:593:33: op= MIN
					{
					DebugLocation(593, 35);
					op=(IToken)Match(input,MIN,Follow._MIN_in_aggregate3103);  
					stream_MIN.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(94); }

				DebugLocation(593, 42);
				OPEN267=(IToken)Match(input,OPEN,Follow._OPEN_in_aggregate3107);  
				stream_OPEN.Add(OPEN267);

				DebugLocation(593, 47);
				PushFollow(Follow._additiveExpression_in_aggregate3109);
				additiveExpression268=additiveExpression();
				PopFollow();

				stream_additiveExpression.Add(additiveExpression268.Tree);
				DebugLocation(593, 66);
				CLOSE269=(IToken)Match(input,CLOSE,Follow._CLOSE_in_aggregate3111);  
				stream_CLOSE.Add(CLOSE269);



				{
				// AST REWRITE
				// elements: additiveExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 594:3: -> ^( AGGREGATE[$op] additiveExpression )
				{
					DebugLocation(594, 6);
					// Hql.g:594:6: ^( AGGREGATE[$op] additiveExpression )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(594, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(AGGREGATE, op), root_1);

					DebugLocation(594, 23);
					adaptor.AddChild(root_1, stream_additiveExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:596:5: COUNT OPEN (s= STAR |p= aggregateDistinctAll ) CLOSE
				{
				DebugLocation(596, 5);
				COUNT270=(IToken)Match(input,COUNT,Follow._COUNT_in_aggregate3130);  
				stream_COUNT.Add(COUNT270);

				DebugLocation(596, 11);
				OPEN271=(IToken)Match(input,OPEN,Follow._OPEN_in_aggregate3132);  
				stream_OPEN.Add(OPEN271);

				DebugLocation(596, 16);
				// Hql.g:596:16: (s= STAR |p= aggregateDistinctAll )
				int alt95=2;
				try { DebugEnterSubRule(95);
				try { DebugEnterDecision(95, false);
				int LA95_1 = input.LA(1);

				if ((LA95_1==STAR))
				{
					alt95 = 1;
				}
				else if ((LA95_1==ALL||LA95_1==DISTINCT||LA95_1==ELEMENTS||LA95_1==IDENT||LA95_1==INDICES))
				{
					alt95 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 95, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(95); }
				switch (alt95)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:596:18: s= STAR
					{
					DebugLocation(596, 19);
					s=(IToken)Match(input,STAR,Follow._STAR_in_aggregate3138);  
					stream_STAR.Add(s);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:596:27: p= aggregateDistinctAll
					{
					DebugLocation(596, 28);
					PushFollow(Follow._aggregateDistinctAll_in_aggregate3144);
					p=aggregateDistinctAll();
					PopFollow();

					stream_aggregateDistinctAll.Add(p.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(95); }

				DebugLocation(596, 52);
				CLOSE272=(IToken)Match(input,CLOSE,Follow._CLOSE_in_aggregate3148);  
				stream_CLOSE.Add(CLOSE272);



				{
				// AST REWRITE
				// elements: COUNT, p, COUNT
				// token labels: 
				// rule labels: p, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 597:3: -> {s == null}? ^( COUNT $p)
				if (s == null)
				{
					DebugLocation(597, 19);
					// Hql.g:597:19: ^( COUNT $p)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(597, 21);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_COUNT.NextNode(), root_1);

					DebugLocation(597, 28);
					adaptor.AddChild(root_1, stream_p.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 598:3: -> ^( COUNT ^( ROW_STAR[\"*\"] ) )
				{
					DebugLocation(598, 6);
					// Hql.g:598:6: ^( COUNT ^( ROW_STAR[\"*\"] ) )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(598, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_COUNT.NextNode(), root_1);

					DebugLocation(598, 14);
					// Hql.g:598:14: ^( ROW_STAR[\"*\"] )
					{
					IASTNode root_2 = (IASTNode)adaptor.Nil();
					DebugLocation(598, 16);
					root_2 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(ROW_STAR, "*"), root_2);

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:599:5: collectionExpr
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(599, 5);
				PushFollow(Follow._collectionExpr_in_aggregate3180);
				collectionExpr273=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr273.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aggregate", 69);
			LeaveRule("aggregate", 69);
			LeaveRule_aggregate();
		}
		DebugLocation(600, 1);
		} finally { DebugExitRule(GrammarFileName, "aggregate"); }
		return retval;

	}
	// $ANTLR end "aggregate"

	partial void EnterRule_aggregateDistinctAll();
	partial void LeaveRule_aggregateDistinctAll();
	// $ANTLR start "aggregateDistinctAll"
	// Hql.g:602:1: aggregateDistinctAll : ( ( DISTINCT | ALL )? ( path | collectionExpr ) ) ;
	[GrammarRule("aggregateDistinctAll")]
	private AstParserRuleReturnScope<IASTNode, IToken> aggregateDistinctAll()
	{
		EnterRule_aggregateDistinctAll();
		EnterRule("aggregateDistinctAll", 70);
		TraceIn("aggregateDistinctAll", 70);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken set274 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path275 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> collectionExpr276 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode set274_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "aggregateDistinctAll");
		DebugLocation(602, 1);
		try
		{
			// Hql.g:603:2: ( ( ( DISTINCT | ALL )? ( path | collectionExpr ) ) )
			DebugEnterAlt(1);
			// Hql.g:603:4: ( ( DISTINCT | ALL )? ( path | collectionExpr ) )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(603, 4);
			// Hql.g:603:4: ( ( DISTINCT | ALL )? ( path | collectionExpr ) )
			DebugEnterAlt(1);
			// Hql.g:603:6: ( DISTINCT | ALL )? ( path | collectionExpr )
			{
			DebugLocation(603, 6);
			// Hql.g:603:6: ( DISTINCT | ALL )?
			int alt97=2;
			try { DebugEnterSubRule(97);
			try { DebugEnterDecision(97, false);
			int LA97_1 = input.LA(1);

			if ((LA97_1==ALL||LA97_1==DISTINCT))
			{
				alt97 = 1;
			}
			} finally { DebugExitDecision(97); }
			switch (alt97)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:
				{
				DebugLocation(603, 6);

				set274=(IToken)input.LT(1);
				if (input.LA(1)==ALL||input.LA(1)==DISTINCT)
				{
					input.Consume();
					adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set274));
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(97); }

			DebugLocation(603, 26);
			// Hql.g:603:26: ( path | collectionExpr )
			int alt98=2;
			try { DebugEnterSubRule(98);
			try { DebugEnterDecision(98, false);
			int LA98_1 = input.LA(1);

			if ((LA98_1==IDENT))
			{
				alt98 = 1;
			}
			else if ((LA98_1==ELEMENTS||LA98_1==INDICES))
			{
				alt98 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 98, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(98); }
			switch (alt98)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:603:28: path
				{
				DebugLocation(603, 28);
				PushFollow(Follow._path_in_aggregateDistinctAll3206);
				path275=path();
				PopFollow();

				adaptor.AddChild(root_0, path275.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:603:35: collectionExpr
				{
				DebugLocation(603, 35);
				PushFollow(Follow._collectionExpr_in_aggregateDistinctAll3210);
				collectionExpr276=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr276.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(98); }


			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aggregateDistinctAll", 70);
			LeaveRule("aggregateDistinctAll", 70);
			LeaveRule_aggregateDistinctAll();
		}
		DebugLocation(604, 1);
		} finally { DebugExitRule(GrammarFileName, "aggregateDistinctAll"); }
		return retval;

	}
	// $ANTLR end "aggregateDistinctAll"

	partial void EnterRule_collectionExpr();
	partial void LeaveRule_collectionExpr();
	// $ANTLR start "collectionExpr"
	// Hql.g:608:1: collectionExpr : ( ELEMENTS ^| INDICES ^) OPEN ! path CLOSE !;
	[GrammarRule("collectionExpr")]
	private AstParserRuleReturnScope<IASTNode, IToken> collectionExpr()
	{
		EnterRule_collectionExpr();
		EnterRule("collectionExpr", 71);
		TraceIn("collectionExpr", 71);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken ELEMENTS277 = default(IToken);
		IToken INDICES278 = default(IToken);
		IToken OPEN279 = default(IToken);
		IToken CLOSE281 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path280 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode ELEMENTS277_tree = default(IASTNode);
		IASTNode INDICES278_tree = default(IASTNode);
		IASTNode OPEN279_tree = default(IASTNode);
		IASTNode CLOSE281_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "collectionExpr");
		DebugLocation(608, 1);
		try
		{
			// Hql.g:609:2: ( ( ELEMENTS ^| INDICES ^) OPEN ! path CLOSE !)
			DebugEnterAlt(1);
			// Hql.g:609:4: ( ELEMENTS ^| INDICES ^) OPEN ! path CLOSE !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(609, 4);
			// Hql.g:609:4: ( ELEMENTS ^| INDICES ^)
			int alt99=2;
			try { DebugEnterSubRule(99);
			try { DebugEnterDecision(99, false);
			int LA99_1 = input.LA(1);

			if ((LA99_1==ELEMENTS))
			{
				alt99 = 1;
			}
			else if ((LA99_1==INDICES))
			{
				alt99 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 99, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(99); }
			switch (alt99)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:609:5: ELEMENTS ^
				{
				DebugLocation(609, 13);
				ELEMENTS277=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_collectionExpr3229); 
				ELEMENTS277_tree = (IASTNode)adaptor.Create(ELEMENTS277);
				root_0 = (IASTNode)adaptor.BecomeRoot(ELEMENTS277_tree, root_0);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:609:17: INDICES ^
				{
				DebugLocation(609, 24);
				INDICES278=(IToken)Match(input,INDICES,Follow._INDICES_in_collectionExpr3234); 
				INDICES278_tree = (IASTNode)adaptor.Create(INDICES278);
				root_0 = (IASTNode)adaptor.BecomeRoot(INDICES278_tree, root_0);

				}
				break;

			}
			} finally { DebugExitSubRule(99); }

			DebugLocation(609, 31);
			OPEN279=(IToken)Match(input,OPEN,Follow._OPEN_in_collectionExpr3238); 
			DebugLocation(609, 33);
			PushFollow(Follow._path_in_collectionExpr3241);
			path280=path();
			PopFollow();

			adaptor.AddChild(root_0, path280.Tree);
			DebugLocation(609, 43);
			CLOSE281=(IToken)Match(input,CLOSE,Follow._CLOSE_in_collectionExpr3243); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionExpr", 71);
			LeaveRule("collectionExpr", 71);
			LeaveRule_collectionExpr();
		}
		DebugLocation(610, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionExpr"); }
		return retval;

	}
	// $ANTLR end "collectionExpr"

	partial void EnterRule_compoundExpr();
	partial void LeaveRule_compoundExpr();
	// $ANTLR start "compoundExpr"
	// Hql.g:612:1: compoundExpr : ( collectionExpr | path | ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !) );
	[GrammarRule("compoundExpr")]
	private AstParserRuleReturnScope<IASTNode, IToken> compoundExpr()
	{
		EnterRule_compoundExpr();
		EnterRule("compoundExpr", 72);
		TraceIn("compoundExpr", 72);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken OPEN284 = default(IToken);
		IToken COMMA287 = default(IToken);
		IToken CLOSE289 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> collectionExpr282 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path283 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> subQuery285 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression286 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression288 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode OPEN284_tree = default(IASTNode);
		IASTNode COMMA287_tree = default(IASTNode);
		IASTNode CLOSE289_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "compoundExpr");
		DebugLocation(612, 1);
		try
		{
			// Hql.g:613:2: ( collectionExpr | path | ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !) )
			int alt102=3;
			try { DebugEnterDecision(102, false);
			switch (input.LA(1))
			{
			case ELEMENTS:
			case INDICES:
				{
				alt102 = 1;
				}
				break;
			case IDENT:
				{
				alt102 = 2;
				}
				break;
			case OPEN:
				{
				alt102 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 102, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(102); }
			switch (alt102)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:613:4: collectionExpr
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(613, 4);
				PushFollow(Follow._collectionExpr_in_compoundExpr3298);
				collectionExpr282=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr282.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:614:4: path
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(614, 4);
				PushFollow(Follow._path_in_compoundExpr3303);
				path283=path();
				PopFollow();

				adaptor.AddChild(root_0, path283.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:615:4: ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !)
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(615, 4);
				// Hql.g:615:4: ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !)
				DebugEnterAlt(1);
				// Hql.g:615:5: OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !
				{
				DebugLocation(615, 9);
				OPEN284=(IToken)Match(input,OPEN,Follow._OPEN_in_compoundExpr3309); 
				DebugLocation(615, 11);
				// Hql.g:615:11: ( subQuery | ( expression ( COMMA ! expression )* ) )
				int alt101=2;
				try { DebugEnterSubRule(101);
				try { DebugEnterDecision(101, false);
				int LA101_1 = input.LA(1);

				if ((LA101_1==EOF||LA101_1==CLOSE||LA101_1==FROM||LA101_1==GROUP||LA101_1==HAVING||LA101_1==ORDER||LA101_1==SELECT||LA101_1==SKIP||LA101_1==TAKE||LA101_1==UNION||LA101_1==WHERE))
				{
					alt101 = 1;
				}
				else if ((LA101_1==ALL||LA101_1==ANY||LA101_1==AVG||LA101_1==BNOT||LA101_1==CASE||LA101_1==COLON||LA101_1==COUNT||LA101_1==ELEMENTS||LA101_1==EMPTY||LA101_1==EXISTS||LA101_1==FALSE||LA101_1==IDENT||LA101_1==INDICES||LA101_1==MAX||(LA101_1>=MIN && LA101_1<=MINUS)||LA101_1==NOT||(LA101_1>=NULL && LA101_1<=NUM_LONG)||LA101_1==OPEN||(LA101_1>=PARAM && LA101_1<=PLUS)||LA101_1==QUOTED_String||LA101_1==SOME||LA101_1==SUM||LA101_1==TRUE))
				{
					alt101 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 101, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(101); }
				switch (alt101)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:615:13: subQuery
					{
					DebugLocation(615, 13);
					PushFollow(Follow._subQuery_in_compoundExpr3314);
					subQuery285=subQuery();
					PopFollow();

					adaptor.AddChild(root_0, subQuery285.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:615:24: ( expression ( COMMA ! expression )* )
					{
					DebugLocation(615, 24);
					// Hql.g:615:24: ( expression ( COMMA ! expression )* )
					DebugEnterAlt(1);
					// Hql.g:615:25: expression ( COMMA ! expression )*
					{
					DebugLocation(615, 25);
					PushFollow(Follow._expression_in_compoundExpr3319);
					expression286=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression286.Tree);
					DebugLocation(615, 36);
					// Hql.g:615:36: ( COMMA ! expression )*
					try { DebugEnterSubRule(100);
					while (true)
					{
						int alt100=2;
						try { DebugEnterDecision(100, false);
						int LA100_1 = input.LA(1);

						if ((LA100_1==COMMA))
						{
							alt100 = 1;
						}


						} finally { DebugExitDecision(100); }
						switch ( alt100 )
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:615:37: COMMA ! expression
							{
							DebugLocation(615, 42);
							COMMA287=(IToken)Match(input,COMMA,Follow._COMMA_in_compoundExpr3322); 
							DebugLocation(615, 44);
							PushFollow(Follow._expression_in_compoundExpr3325);
							expression288=expression();
							PopFollow();

							adaptor.AddChild(root_0, expression288.Tree);

							}
							break;

						default:
							goto loop100;
						}
					}

					loop100:
						;

					} finally { DebugExitSubRule(100); }


					}


					}
					break;

				}
				} finally { DebugExitSubRule(101); }

				DebugLocation(615, 65);
				CLOSE289=(IToken)Match(input,CLOSE,Follow._CLOSE_in_compoundExpr3332); 

				}


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compoundExpr", 72);
			LeaveRule("compoundExpr", 72);
			LeaveRule_compoundExpr();
		}
		DebugLocation(616, 1);
		} finally { DebugExitRule(GrammarFileName, "compoundExpr"); }
		return retval;

	}
	// $ANTLR end "compoundExpr"

	partial void EnterRule_exprList();
	partial void LeaveRule_exprList();
	// $ANTLR start "exprList"
	// Hql.g:618:1: exprList : ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )? ;
	[GrammarRule("exprList")]
	private AstParserRuleReturnScope<IASTNode, IToken> exprList()
	{
		EnterRule_exprList();
		EnterRule("exprList", 73);
		TraceIn("exprList", 73);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken f = default(IToken);
		IToken f2 = default(IToken);
		IToken TRAILING290 = default(IToken);
		IToken LEADING291 = default(IToken);
		IToken BOTH292 = default(IToken);
		IToken COMMA294 = default(IToken);
		IToken AS297 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> expression293 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression295 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression296 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier298 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression299 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode f_tree = default(IASTNode);
		IASTNode f2_tree = default(IASTNode);
		IASTNode TRAILING290_tree = default(IASTNode);
		IASTNode LEADING291_tree = default(IASTNode);
		IASTNode BOTH292_tree = default(IASTNode);
		IASTNode COMMA294_tree = default(IASTNode);
		IASTNode AS297_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "exprList");
		DebugLocation(618, 1);
		try
		{
			// Hql.g:624:2: ( ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )? )
			DebugEnterAlt(1);
			// Hql.g:624:4: ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(624, 4);
			// Hql.g:624:4: ( TRAILING | LEADING | BOTH )?
			int alt103=4;
			try { DebugEnterSubRule(103);
			try { DebugEnterDecision(103, false);
			switch (input.LA(1))
			{
			case TRAILING:
				{
				alt103 = 1;
				}
				break;
			case LEADING:
				{
				alt103 = 2;
				}
				break;
			case BOTH:
				{
				alt103 = 3;
				}
				break;
			}

			} finally { DebugExitDecision(103); }
			switch (alt103)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:624:5: TRAILING
				{
				DebugLocation(624, 5);
				TRAILING290=(IToken)Match(input,TRAILING,Follow._TRAILING_in_exprList3351); 
				TRAILING290_tree = (IASTNode)adaptor.Create(TRAILING290);
				adaptor.AddChild(root_0, TRAILING290_tree);
				DebugLocation(624, 14);
				TRAILING290.Type = IDENT;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:625:10: LEADING
				{
				DebugLocation(625, 10);
				LEADING291=(IToken)Match(input,LEADING,Follow._LEADING_in_exprList3364); 
				LEADING291_tree = (IASTNode)adaptor.Create(LEADING291);
				adaptor.AddChild(root_0, LEADING291_tree);
				DebugLocation(625, 18);
				LEADING291.Type = IDENT;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:626:10: BOTH
				{
				DebugLocation(626, 10);
				BOTH292=(IToken)Match(input,BOTH,Follow._BOTH_in_exprList3377); 
				BOTH292_tree = (IASTNode)adaptor.Create(BOTH292);
				adaptor.AddChild(root_0, BOTH292_tree);
				DebugLocation(626, 15);
				BOTH292.Type = IDENT;

				}
				break;

			}
			} finally { DebugExitSubRule(103); }

			DebugLocation(628, 4);
			// Hql.g:628:4: ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )?
			int alt106=3;
			try { DebugEnterSubRule(106);
			try { DebugEnterDecision(106, false);
			int LA106_1 = input.LA(1);

			if ((LA106_1==ALL||LA106_1==ANY||LA106_1==AVG||LA106_1==BNOT||LA106_1==CASE||LA106_1==COLON||LA106_1==COUNT||LA106_1==ELEMENTS||LA106_1==EMPTY||LA106_1==EXISTS||LA106_1==FALSE||LA106_1==IDENT||LA106_1==INDICES||LA106_1==MAX||(LA106_1>=MIN && LA106_1<=MINUS)||LA106_1==NOT||(LA106_1>=NULL && LA106_1<=NUM_LONG)||LA106_1==OPEN||(LA106_1>=PARAM && LA106_1<=PLUS)||LA106_1==QUOTED_String||LA106_1==SOME||LA106_1==SUM||LA106_1==TRUE))
			{
				alt106 = 1;
			}
			else if ((LA106_1==FROM))
			{
				alt106 = 2;
			}
			} finally { DebugExitDecision(106); }
			switch (alt106)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:629:5: expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )?
				{
				DebugLocation(629, 5);
				PushFollow(Follow._expression_in_exprList3401);
				expression293=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression293.Tree);
				DebugLocation(629, 16);
				// Hql.g:629:16: ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )?
				int alt105=4;
				try { DebugEnterSubRule(105);
				try { DebugEnterDecision(105, false);
				switch (input.LA(1))
				{
				case COMMA:
					{
					alt105 = 1;
					}
					break;
				case FROM:
					{
					alt105 = 2;
					}
					break;
				case AS:
					{
					alt105 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(105); }
				switch (alt105)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:629:18: ( COMMA ! expression )+
					{
					DebugLocation(629, 18);
					// Hql.g:629:18: ( COMMA ! expression )+
					int cnt104=0;
					try { DebugEnterSubRule(104);
					while (true)
					{
						int alt104=2;
						try { DebugEnterDecision(104, false);
						int LA104_1 = input.LA(1);

						if ((LA104_1==COMMA))
						{
							alt104 = 1;
						}


						} finally { DebugExitDecision(104); }
						switch (alt104)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:629:19: COMMA ! expression
							{
							DebugLocation(629, 24);
							COMMA294=(IToken)Match(input,COMMA,Follow._COMMA_in_exprList3406); 
							DebugLocation(629, 26);
							PushFollow(Follow._expression_in_exprList3409);
							expression295=expression();
							PopFollow();

							adaptor.AddChild(root_0, expression295.Tree);

							}
							break;

						default:
							if (cnt104 >= 1)
								goto loop104;

							EarlyExitException eee104 = new EarlyExitException( 104, input );
							DebugRecognitionException(eee104);
							throw eee104;
						}
						cnt104++;
					}
					loop104:
						;

					} finally { DebugExitSubRule(104); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:630:9: f= FROM expression
					{
					DebugLocation(630, 10);
					f=(IToken)Match(input,FROM,Follow._FROM_in_exprList3424); 
					f_tree = (IASTNode)adaptor.Create(f);
					adaptor.AddChild(root_0, f_tree);
					DebugLocation(630, 16);
					PushFollow(Follow._expression_in_exprList3426);
					expression296=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression296.Tree);
					DebugLocation(630, 27);
					f.Type = IDENT;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:631:9: AS ! identifier
					{
					DebugLocation(631, 11);
					AS297=(IToken)Match(input,AS,Follow._AS_in_exprList3438); 
					DebugLocation(631, 13);
					PushFollow(Follow._identifier_in_exprList3441);
					identifier298=identifier();
					PopFollow();

					adaptor.AddChild(root_0, identifier298.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(105); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:632:7: f2= FROM expression
				{
				DebugLocation(632, 9);
				f2=(IToken)Match(input,FROM,Follow._FROM_in_exprList3455); 
				f2_tree = (IASTNode)adaptor.Create(f2);
				adaptor.AddChild(root_0, f2_tree);
				DebugLocation(632, 15);
				PushFollow(Follow._expression_in_exprList3457);
				expression299=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression299.Tree);
				DebugLocation(632, 26);
				f2.Type = IDENT;

				}
				break;

			}
			} finally { DebugExitSubRule(106); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);


			   IASTNode root = (IASTNode) adaptor.Create(EXPR_LIST, "exprList");
			   root.AddChild((IASTNode)retval.Tree);
			   retval.Tree = root;

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprList", 73);
			LeaveRule("exprList", 73);
			LeaveRule_exprList();
		}
		DebugLocation(634, 1);
		} finally { DebugExitRule(GrammarFileName, "exprList"); }
		return retval;

	}
	// $ANTLR end "exprList"

	partial void EnterRule_subQuery();
	partial void LeaveRule_subQuery();
	// $ANTLR start "subQuery"
	// Hql.g:636:1: subQuery : innerSubQuery ( UNION ^ innerSubQuery )* ;
	[GrammarRule("subQuery")]
	private AstParserRuleReturnScope<IASTNode, IToken> subQuery()
	{
		EnterRule_subQuery();
		EnterRule("subQuery", 74);
		TraceIn("subQuery", 74);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken UNION301 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> innerSubQuery300 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> innerSubQuery302 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode UNION301_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "subQuery");
		DebugLocation(636, 1);
		try
		{
			// Hql.g:637:2: ( innerSubQuery ( UNION ^ innerSubQuery )* )
			DebugEnterAlt(1);
			// Hql.g:637:4: innerSubQuery ( UNION ^ innerSubQuery )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(637, 4);
			PushFollow(Follow._innerSubQuery_in_subQuery3477);
			innerSubQuery300=innerSubQuery();
			PopFollow();

			adaptor.AddChild(root_0, innerSubQuery300.Tree);
			DebugLocation(637, 18);
			// Hql.g:637:18: ( UNION ^ innerSubQuery )*
			try { DebugEnterSubRule(107);
			while (true)
			{
				int alt107=2;
				try { DebugEnterDecision(107, false);
				int LA107_1 = input.LA(1);

				if ((LA107_1==UNION))
				{
					alt107 = 1;
				}


				} finally { DebugExitDecision(107); }
				switch ( alt107 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:637:19: UNION ^ innerSubQuery
					{
					DebugLocation(637, 24);
					UNION301=(IToken)Match(input,UNION,Follow._UNION_in_subQuery3480); 
					UNION301_tree = (IASTNode)adaptor.Create(UNION301);
					root_0 = (IASTNode)adaptor.BecomeRoot(UNION301_tree, root_0);
					DebugLocation(637, 26);
					PushFollow(Follow._innerSubQuery_in_subQuery3483);
					innerSubQuery302=innerSubQuery();
					PopFollow();

					adaptor.AddChild(root_0, innerSubQuery302.Tree);

					}
					break;

				default:
					goto loop107;
				}
			}

			loop107:
				;

			} finally { DebugExitSubRule(107); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subQuery", 74);
			LeaveRule("subQuery", 74);
			LeaveRule_subQuery();
		}
		DebugLocation(638, 1);
		} finally { DebugExitRule(GrammarFileName, "subQuery"); }
		return retval;

	}
	// $ANTLR end "subQuery"

	partial void EnterRule_innerSubQuery();
	partial void LeaveRule_innerSubQuery();
	// $ANTLR start "innerSubQuery"
	// Hql.g:640:1: innerSubQuery : queryRule -> ^( QUERY[\"query\"] queryRule ) ;
	[GrammarRule("innerSubQuery")]
	private AstParserRuleReturnScope<IASTNode, IToken> innerSubQuery()
	{
		EnterRule_innerSubQuery();
		EnterRule("innerSubQuery", 75);
		TraceIn("innerSubQuery", 75);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> queryRule303 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_queryRule=new RewriteRuleSubtreeStream(adaptor,"rule queryRule");
		try { DebugEnterRule(GrammarFileName, "innerSubQuery");
		DebugLocation(640, 1);
		try
		{
			// Hql.g:641:2: ( queryRule -> ^( QUERY[\"query\"] queryRule ) )
			DebugEnterAlt(1);
			// Hql.g:641:4: queryRule
			{
			DebugLocation(641, 4);
			PushFollow(Follow._queryRule_in_innerSubQuery3497);
			queryRule303=queryRule();
			PopFollow();

			stream_queryRule.Add(queryRule303.Tree);


			{
			// AST REWRITE
			// elements: queryRule
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 642:2: -> ^( QUERY[\"query\"] queryRule )
			{
				DebugLocation(642, 5);
				// Hql.g:642:5: ^( QUERY[\"query\"] queryRule )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(642, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(QUERY, "query"), root_1);

				DebugLocation(642, 22);
				adaptor.AddChild(root_1, stream_queryRule.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("innerSubQuery", 75);
			LeaveRule("innerSubQuery", 75);
			LeaveRule_innerSubQuery();
		}
		DebugLocation(643, 1);
		} finally { DebugExitRule(GrammarFileName, "innerSubQuery"); }
		return retval;

	}
	// $ANTLR end "innerSubQuery"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();
	// $ANTLR start "constant"
	// Hql.g:645:1: constant : ( NUM_INT | NUM_FLOAT | NUM_LONG | NUM_DOUBLE | NUM_DECIMAL | QUOTED_String | NULL | TRUE | FALSE | EMPTY );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<IASTNode, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 76);
		TraceIn("constant", 76);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken set304 = default(IToken);

		IASTNode set304_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(645, 1);
		try
		{
			// Hql.g:646:2: ( NUM_INT | NUM_FLOAT | NUM_LONG | NUM_DOUBLE | NUM_DECIMAL | QUOTED_String | NULL | TRUE | FALSE | EMPTY )
			DebugEnterAlt(1);
			// Hql.g:
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(646, 2);

			set304=(IToken)input.LT(1);
			if (input.LA(1)==EMPTY||input.LA(1)==FALSE||(input.LA(1)>=NULL && input.LA(1)<=NUM_LONG)||input.LA(1)==QUOTED_String||input.LA(1)==TRUE)
			{
				input.Consume();
				adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set304));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 76);
			LeaveRule("constant", 76);
			LeaveRule_constant();
		}
		DebugLocation(656, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_path();
	partial void LeaveRule_path();
	// $ANTLR start "path"
	// Hql.g:664:1: path : identifier ( DOT ^ identifier )* ;
	[GrammarRule("path")]
	private AstParserRuleReturnScope<IASTNode, IToken> path()
	{
		EnterRule_path();
		EnterRule("path", 77);
		TraceIn("path", 77);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken DOT306 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identifier305 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier307 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode DOT306_tree = default(IASTNode);

		// TODO - need to clean up DotIdent - suspect that DotIdent2 supersedes the other one, but need to do the analysis
		//HandleDotIdent2();

		try { DebugEnterRule(GrammarFileName, "path");
		DebugLocation(664, 1);
		try
		{
			// Hql.g:669:2: ( identifier ( DOT ^ identifier )* )
			DebugEnterAlt(1);
			// Hql.g:669:4: identifier ( DOT ^ identifier )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(669, 4);
			PushFollow(Follow._identifier_in_path3585);
			identifier305=identifier();
			PopFollow();

			adaptor.AddChild(root_0, identifier305.Tree);
			DebugLocation(669, 15);
			// Hql.g:669:15: ( DOT ^ identifier )*
			try { DebugEnterSubRule(108);
			while (true)
			{
				int alt108=2;
				try { DebugEnterDecision(108, false);
				int LA108_1 = input.LA(1);

				if ((LA108_1==DOT))
				{
					alt108 = 1;
				}


				} finally { DebugExitDecision(108); }
				switch ( alt108 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:669:17: DOT ^ identifier
					{
					DebugLocation(669, 20);
					DOT306=(IToken)Match(input,DOT,Follow._DOT_in_path3589); 
					DOT306_tree = (IASTNode)adaptor.Create(DOT306);
					root_0 = (IASTNode)adaptor.BecomeRoot(DOT306_tree, root_0);
					DebugLocation(669, 22);
					 WeakKeywords(); 
					DebugLocation(669, 42);
					PushFollow(Follow._identifier_in_path3594);
					identifier307=identifier();
					PopFollow();

					adaptor.AddChild(root_0, identifier307.Tree);

					}
					break;

				default:
					goto loop108;
				}
			}

			loop108:
				;

			} finally { DebugExitSubRule(108); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("path", 77);
			LeaveRule("path", 77);
			LeaveRule_path();
		}
		DebugLocation(670, 1);
		} finally { DebugExitRule(GrammarFileName, "path"); }
		return retval;

	}
	// $ANTLR end "path"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();
	// $ANTLR start "identifier"
	// Hql.g:674:1: identifier : IDENT ;
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<IASTNode, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 78);
		TraceIn("identifier", 78);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken IDENT308 = default(IToken);

		IASTNode IDENT308_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(674, 1);
		try
		{
			// Hql.g:675:2: ( IDENT )
			DebugEnterAlt(1);
			// Hql.g:675:4: IDENT
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(675, 4);
			IDENT308=(IToken)Match(input,IDENT,Follow._IDENT_in_identifier3610); 
			IDENT308_tree = (IASTNode)adaptor.Create(IDENT308);
			adaptor.AddChild(root_0, IDENT308_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException ex)
		{

					retval.Tree = HandleIdentifierError(input.LT(1),ex);
				
		}

		finally
		{
			TraceOut("identifier", 78);
			LeaveRule("identifier", 78);
			LeaveRule_identifier();
		}
		DebugLocation(676, 1);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _updateStatement_in_statement613 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _deleteStatement_in_statement617 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _selectStatement_in_statement621 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _insertStatement_in_statement625 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_statement629 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _UPDATE_in_updateStatement641 = new BitSet(new ulong[]{0x81000000000000UL,0x8000000000000000UL});
		public static readonly BitSet _VERSIONED_in_updateStatement645 = new BitSet(new ulong[]{0x81000000000000UL});
		public static readonly BitSet _optionalFromTokenFromClause_in_updateStatement651 = new BitSet(new ulong[]{0x0UL,0x1000000000000UL});
		public static readonly BitSet _setClause_in_updateStatement655 = new BitSet(new ulong[]{0x2UL,0x0UL,0x4UL});
		public static readonly BitSet _whereClause_in_updateStatement660 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SET_in_setClause674 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _assignment_in_setClause677 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_setClause680 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _assignment_in_setClause683 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _stateField_in_assignment697 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _EQ_in_assignment699 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _newValue_in_assignment702 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_stateField715 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concatenation_in_newValue728 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DELETE_in_deleteStatement739 = new BitSet(new ulong[]{0x81000000000000UL});
		public static readonly BitSet _optionalFromTokenFromClause_in_deleteStatement745 = new BitSet(new ulong[]{0x2UL,0x0UL,0x4UL});
		public static readonly BitSet _whereClause_in_deleteStatement751 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _optionalFromTokenFromClause2_in_optionalFromTokenFromClause766 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_optionalFromTokenFromClause768 = new BitSet(new ulong[]{0x80000000000202UL});
		public static readonly BitSet _asAlias_in_optionalFromTokenFromClause771 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FROM_in_optionalFromTokenFromClause2802 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _queryRule_in_selectStatement816 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INSERT_in_insertStatement845 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _intoClause_in_insertStatement848 = new BitSet(new ulong[]{0x29000000000000UL,0x42400800000000UL,0x4UL});
		public static readonly BitSet _selectStatement_in_insertStatement850 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTO_in_intoClause861 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_intoClause864 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _insertablePropertySpec_in_intoClause868 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_insertablePropertySpec879 = new BitSet(new ulong[]{0x1080101410800800UL,0x22004411F809000UL});
		public static readonly BitSet _primaryExpression_in_insertablePropertySpec881 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _COMMA_in_insertablePropertySpec885 = new BitSet(new ulong[]{0x1080101410800800UL,0x22004411F809000UL});
		public static readonly BitSet _primaryExpression_in_insertablePropertySpec887 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _CLOSE_in_insertablePropertySpec892 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectFrom_in_queryRule918 = new BitSet(new ulong[]{0x28000000000002UL,0x42000800000000UL,0x4UL});
		public static readonly BitSet _whereClause_in_queryRule923 = new BitSet(new ulong[]{0x28000000000002UL,0x42000800000000UL});
		public static readonly BitSet _groupByClause_in_queryRule930 = new BitSet(new ulong[]{0x20000000000002UL,0x42000800000000UL});
		public static readonly BitSet _havingClause_in_queryRule937 = new BitSet(new ulong[]{0x2UL,0x42000800000000UL});
		public static readonly BitSet _orderByClause_in_queryRule944 = new BitSet(new ulong[]{0x2UL,0x42000000000000UL});
		public static readonly BitSet _skipClause_in_queryRule951 = new BitSet(new ulong[]{0x2UL,0x40000000000000UL});
		public static readonly BitSet _takeClause_in_queryRule958 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectClause_in_selectFrom976 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _fromClause_in_selectFrom983 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SELECT_in_selectClause1032 = new BitSet(new ulong[]{0x1080121490844940UL,0x22404C13F8D9000UL});
		public static readonly BitSet _DISTINCT_in_selectClause1044 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C13F8D9000UL});
		public static readonly BitSet _selectedPropertiesList_in_selectClause1050 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _newExpression_in_selectClause1054 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectObject_in_selectClause1058 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_newExpression1072 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_newExpression1074 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_newExpression1079 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _selectedPropertiesList_in_newExpression1081 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_newExpression1083 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBJECT_in_selectObject1109 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_selectObject1112 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_selectObject1115 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_selectObject1117 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FROM_in_fromClause1135 = new BitSet(new ulong[]{0x480000400000000UL});
		public static readonly BitSet _fromRange_in_fromClause1140 = new BitSet(new ulong[]{0x2002000001000002UL,0x100000000120UL});
		public static readonly BitSet _fromJoin_in_fromClause1144 = new BitSet(new ulong[]{0x2002000001000002UL,0x100000000120UL});
		public static readonly BitSet _COMMA_in_fromClause1148 = new BitSet(new ulong[]{0x480000400000000UL});
		public static readonly BitSet _fromRange_in_fromClause1153 = new BitSet(new ulong[]{0x2002000001000002UL,0x100000000120UL});
		public static readonly BitSet _set_in_fromJoin1171 = new BitSet(new ulong[]{0x0UL,0x2000000020UL});
		public static readonly BitSet _OUTER_in_fromJoin1182 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _FULL_in_fromJoin1190 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _INNER_in_fromJoin1194 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _JOIN_in_fromJoin1199 = new BitSet(new ulong[]{0x80200000000000UL});
		public static readonly BitSet _FETCH_in_fromJoin1203 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_fromJoin1207 = new BitSet(new ulong[]{0x80200000000202UL,0x0UL,0x8UL});
		public static readonly BitSet _asAlias_in_fromJoin1210 = new BitSet(new ulong[]{0x200000000002UL,0x0UL,0x8UL});
		public static readonly BitSet _propertyFetch_in_fromJoin1215 = new BitSet(new ulong[]{0x2UL,0x0UL,0x8UL});
		public static readonly BitSet _withClause_in_fromJoin1220 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_fromJoin1231 = new BitSet(new ulong[]{0x0UL,0x2000000020UL});
		public static readonly BitSet _OUTER_in_fromJoin1242 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _FULL_in_fromJoin1250 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _INNER_in_fromJoin1254 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _JOIN_in_fromJoin1259 = new BitSet(new ulong[]{0x200400000000UL});
		public static readonly BitSet _FETCH_in_fromJoin1263 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _ELEMENTS_in_fromJoin1267 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_fromJoin1270 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_fromJoin1273 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_fromJoin1275 = new BitSet(new ulong[]{0x80200000000202UL,0x0UL,0x8UL});
		public static readonly BitSet _asAlias_in_fromJoin1279 = new BitSet(new ulong[]{0x200000000002UL,0x0UL,0x8UL});
		public static readonly BitSet _propertyFetch_in_fromJoin1284 = new BitSet(new ulong[]{0x2UL,0x0UL,0x8UL});
		public static readonly BitSet _withClause_in_fromJoin1289 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WITH_in_withClause1302 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_withClause1305 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _fromClassOrOuterQueryPath_in_fromRange1316 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inClassDeclaration_in_fromRange1321 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inCollectionDeclaration_in_fromRange1326 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inCollectionElementsDeclaration_in_fromRange1331 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_fromClassOrOuterQueryPath1343 = new BitSet(new ulong[]{0x80200000000202UL});
		public static readonly BitSet _asAlias_in_fromClassOrOuterQueryPath1348 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _propertyFetch_in_fromClassOrOuterQueryPath1353 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_in_inClassDeclaration1383 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _IN_in_inClassDeclaration1385 = new BitSet(new ulong[]{0x80000000100000UL});
		public static readonly BitSet _CLASS_in_inClassDeclaration1387 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inClassDeclaration1390 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IN_in_inCollectionDeclaration1418 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_inCollectionDeclaration1420 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inCollectionDeclaration1422 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_inCollectionDeclaration1424 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _alias_in_inCollectionDeclaration1426 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_in_inCollectionElementsDeclaration1460 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _IN_in_inCollectionElementsDeclaration1462 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _ELEMENTS_in_inCollectionElementsDeclaration1464 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_inCollectionElementsDeclaration1466 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inCollectionElementsDeclaration1468 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_inCollectionElementsDeclaration1470 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELEMENTS_in_inCollectionElementsDeclaration1492 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_inCollectionElementsDeclaration1494 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inCollectionElementsDeclaration1496 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_inCollectionElementsDeclaration1498 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _AS_in_inCollectionElementsDeclaration1500 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _alias_in_inCollectionElementsDeclaration1502 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AS_in_asAlias1534 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _alias_in_asAlias1539 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_alias1551 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FETCH_in_propertyFetch1570 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ALL_in_propertyFetch1572 = new BitSet(new ulong[]{0x0UL,0x10000000000UL});
		public static readonly BitSet _PROPERTIES_in_propertyFetch1575 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GROUP_in_groupByClause1587 = new BitSet(new ulong[]{0x0UL,0x400UL});
		public static readonly BitSet _LITERAL_by_in_groupByClause1593 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_groupByClause1596 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_groupByClause1600 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_groupByClause1603 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _ORDER_in_orderByClause1617 = new BitSet(new ulong[]{0x0UL,0x400UL});
		public static readonly BitSet _LITERAL_by_in_orderByClause1620 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _orderElement_in_orderByClause1623 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_orderByClause1627 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _orderElement_in_orderByClause1630 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _SKIP_in_skipClause1644 = new BitSet(new ulong[]{0x800000UL,0x4008000000UL});
		public static readonly BitSet _NUM_INT_in_skipClause1648 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_skipClause1652 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TAKE_in_takeClause1664 = new BitSet(new ulong[]{0x800000UL,0x4008000000UL});
		public static readonly BitSet _NUM_INT_in_takeClause1668 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_takeClause1672 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_parameter1684 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_parameter1687 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARAM_in_parameter1692 = new BitSet(new ulong[]{0x2UL,0x8000000UL});
		public static readonly BitSet _NUM_INT_in_parameter1696 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_orderElement1709 = new BitSet(new ulong[]{0x40000402UL,0x0UL,0x60UL});
		public static readonly BitSet _ascendingOrDescending_in_orderElement1713 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASCENDING_in_ascendingOrDescending1731 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _133_in_ascendingOrDescending1737 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DESCENDING_in_ascendingOrDescending1757 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _134_in_ascendingOrDescending1763 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HAVING_in_havingClause1784 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_havingClause1787 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHERE_in_whereClause1798 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_whereClause1801 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aliasedExpression_in_selectedPropertiesList1812 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_selectedPropertiesList1816 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _aliasedExpression_in_selectedPropertiesList1819 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _expression_in_aliasedExpression1834 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _AS_in_aliasedExpression1838 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_aliasedExpression1841 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_logicalExpression1880 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalOrExpression_in_expression1892 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression1904 = new BitSet(new ulong[]{0x2UL,0x400000000UL});
		public static readonly BitSet _OR_in_logicalOrExpression1908 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression1911 = new BitSet(new ulong[]{0x2UL,0x400000000UL});
		public static readonly BitSet _negatedExpression_in_logicalAndExpression1926 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _AND_in_logicalAndExpression1930 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _negatedExpression_in_logicalAndExpression1933 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _NOT_in_negatedExpression1954 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _negatedExpression_in_negatedExpression1958 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equalityExpression_in_negatedExpression1971 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression1993 = new BitSet(new ulong[]{0x4000000002UL,0x8000000020002UL});
		public static readonly BitSet _EQ_in_equalityExpression2001 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _IS_in_equalityExpression2010 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _NOT_in_equalityExpression2016 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _NE_in_equalityExpression2028 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _SQL_NE_in_equalityExpression2037 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression2048 = new BitSet(new ulong[]{0x4000000002UL,0x8000000020002UL});
		public static readonly BitSet _concatenation_in_relationalExpression2065 = new BitSet(new ulong[]{0x414000000002002UL,0x82A40UL});
		public static readonly BitSet _LT_in_relationalExpression2077 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _GT_in_relationalExpression2082 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _LE_in_relationalExpression2087 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _GE_in_relationalExpression2092 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseNotExpression_in_relationalExpression2097 = new BitSet(new ulong[]{0x14000000000002UL,0x840UL});
		public static readonly BitSet _NOT_in_relationalExpression2114 = new BitSet(new ulong[]{0x400000000002000UL,0x2200UL});
		public static readonly BitSet _IN_in_relationalExpression2135 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _inList_in_relationalExpression2144 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BETWEEN_in_relationalExpression2155 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _betweenList_in_relationalExpression2164 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LIKE_in_relationalExpression2176 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _concatenation_in_relationalExpression2185 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _likeEscape_in_relationalExpression2187 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MEMBER_in_relationalExpression2196 = new BitSet(new ulong[]{0x80000000000000UL,0x40000000UL});
		public static readonly BitSet _OF_in_relationalExpression2200 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_relationalExpression2207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ESCAPE_in_likeEscape2234 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _concatenation_in_likeEscape2237 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _compoundExpr_in_inList2250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concatenation_in_betweenList2271 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _AND_in_betweenList2273 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _concatenation_in_betweenList2276 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseNotExpression_in_concatenation2295 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _CONCAT_in_concatenation2303 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseNotExpression_in_concatenation2312 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _CONCAT_in_concatenation2319 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseNotExpression_in_concatenation2322 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _BNOT_in_bitwiseNotExpression2346 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseOrExpression_in_bitwiseNotExpression2349 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseOrExpression_in_bitwiseNotExpression2355 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseXOrExpression_in_bitwiseOrExpression2367 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _BOR_in_bitwiseOrExpression2370 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseXOrExpression_in_bitwiseOrExpression2373 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXOrExpression2387 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _BXOR_in_bitwiseXOrExpression2390 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXOrExpression2393 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _additiveExpression_in_bitwiseAndExpression2407 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _BAND_in_bitwiseAndExpression2410 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _additiveExpression_in_bitwiseAndExpression2413 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _multiplyExpression_in_additiveExpression2427 = new BitSet(new ulong[]{0x2UL,0x8000010000UL});
		public static readonly BitSet _PLUS_in_additiveExpression2433 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _MINUS_in_additiveExpression2438 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _multiplyExpression_in_additiveExpression2443 = new BitSet(new ulong[]{0x2UL,0x8000010000UL});
		public static readonly BitSet _unaryExpression_in_multiplyExpression2458 = new BitSet(new ulong[]{0x100000002UL,0x10000000000000UL});
		public static readonly BitSet _STAR_in_multiplyExpression2464 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _DIV_in_multiplyExpression2469 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_multiplyExpression2474 = new BitSet(new ulong[]{0x100000002UL,0x10000000000000UL});
		public static readonly BitSet _MINUS_in_unaryExpression2492 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression2496 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_unaryExpression2513 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression2517 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _caseExpression_in_unaryExpression2532 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quantifiedExpression_in_unaryExpression2537 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_unaryExpression2542 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseExpression2554 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _whenClause_in_caseExpression2557 = new BitSet(new ulong[]{0x2800000000UL,0x0UL,0x2UL});
		public static readonly BitSet _elseClause_in_caseExpression2562 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _END_in_caseExpression2566 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseExpression2586 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_caseExpression2588 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _altWhenClause_in_caseExpression2591 = new BitSet(new ulong[]{0x2800000000UL,0x0UL,0x2UL});
		public static readonly BitSet _elseClause_in_caseExpression2596 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _END_in_caseExpression2600 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHEN_in_whenClause2629 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_whenClause2632 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _THEN_in_whenClause2634 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_whenClause2637 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHEN_in_altWhenClause2651 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_altWhenClause2654 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _THEN_in_altWhenClause2656 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_altWhenClause2659 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_elseClause2673 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_elseClause2676 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SOME_in_quantifiedExpression2691 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _EXISTS_in_quantifiedExpression2696 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _ALL_in_quantifiedExpression2701 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _ANY_in_quantifiedExpression2706 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _identifier_in_quantifiedExpression2715 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_quantifiedExpression2719 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_quantifiedExpression2724 = new BitSet(new ulong[]{0x29000000000000UL,0x42400800000000UL,0x4UL});
		public static readonly BitSet _subQuery_in_quantifiedExpression2729 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_quantifiedExpression2733 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_atom2752 = new BitSet(new ulong[]{0x200000002UL,0x200000000UL});
		public static readonly BitSet _DOT_in_atom2761 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_atom2764 = new BitSet(new ulong[]{0x200000002UL,0x300000000UL});
		public static readonly BitSet _OPEN_in_atom2792 = new BitSet(new ulong[]{0x1081121410A54940UL,0x32404C11F899080UL});
		public static readonly BitSet _exprList_in_atom2797 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_atom2799 = new BitSet(new ulong[]{0x200000002UL,0x200000000UL});
		public static readonly BitSet _OPEN_BRACKET_in_atom2813 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_atom2818 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _CLOSE_BRACKET_in_atom2820 = new BitSet(new ulong[]{0x200000002UL,0x200000000UL});
		public static readonly BitSet _identPrimary_in_primaryExpression2840 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _DOT_in_primaryExpression2853 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _CLASS_in_primaryExpression2856 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primaryExpression2866 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_primaryExpression2873 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_primaryExpression2876 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_primaryExpression2885 = new BitSet(new ulong[]{0x10A9121410844940UL,0x26644C91F899000UL,0x4UL});
		public static readonly BitSet _expressionOrVector_in_primaryExpression2889 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _subQuery_in_primaryExpression2893 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_primaryExpression2896 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARAM_in_primaryExpression2904 = new BitSet(new ulong[]{0x2UL,0x8000000UL});
		public static readonly BitSet _NUM_INT_in_primaryExpression2908 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressionOrVector2926 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _vectorExpr_in_expressionOrVector2932 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_vectorExpr2969 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_vectorExpr2972 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_vectorExpr2975 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_vectorExpr2978 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _identifier_in_identPrimary2994 = new BitSet(new ulong[]{0x200000002UL,0x100000000UL});
		public static readonly BitSet _DOT_in_identPrimary3012 = new BitSet(new ulong[]{0x80000000000000UL,0x20000000UL});
		public static readonly BitSet _identifier_in_identPrimary3017 = new BitSet(new ulong[]{0x200000002UL,0x100000000UL});
		public static readonly BitSet _OBJECT_in_identPrimary3023 = new BitSet(new ulong[]{0x200000002UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_identPrimary3041 = new BitSet(new ulong[]{0x1081121410A54940UL,0x32404C11F899080UL});
		public static readonly BitSet _exprList_in_identPrimary3046 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_identPrimary3048 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aggregate_in_identPrimary3064 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUM_in_aggregate3085 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _AVG_in_aggregate3091 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _MAX_in_aggregate3097 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _MIN_in_aggregate3103 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_aggregate3107 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _additiveExpression_in_aggregate3109 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_aggregate3111 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COUNT_in_aggregate3130 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_aggregate3132 = new BitSet(new ulong[]{0x1080000480000040UL,0x10000000000000UL});
		public static readonly BitSet _STAR_in_aggregate3138 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _aggregateDistinctAll_in_aggregate3144 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_aggregate3148 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_aggregate3180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_aggregateDistinctAll3206 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_aggregateDistinctAll3210 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELEMENTS_in_collectionExpr3229 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _INDICES_in_collectionExpr3234 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_collectionExpr3238 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_collectionExpr3241 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_collectionExpr3243 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_compoundExpr3298 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_compoundExpr3303 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_compoundExpr3309 = new BitSet(new ulong[]{0x10A9121410844940UL,0x26644C91F899000UL,0x4UL});
		public static readonly BitSet _subQuery_in_compoundExpr3314 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _expression_in_compoundExpr3319 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _COMMA_in_compoundExpr3322 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_compoundExpr3325 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _CLOSE_in_compoundExpr3332 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRAILING_in_exprList3351 = new BitSet(new ulong[]{0x1081121410844942UL,0x22404C11F899000UL});
		public static readonly BitSet _LEADING_in_exprList3364 = new BitSet(new ulong[]{0x1081121410844942UL,0x22404C11F899000UL});
		public static readonly BitSet _BOTH_in_exprList3377 = new BitSet(new ulong[]{0x1081121410844942UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3401 = new BitSet(new ulong[]{0x1000001000202UL});
		public static readonly BitSet _COMMA_in_exprList3406 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3409 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _FROM_in_exprList3424 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3426 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AS_in_exprList3438 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_exprList3441 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FROM_in_exprList3455 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3457 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _innerSubQuery_in_subQuery3477 = new BitSet(new ulong[]{0x2UL,0x1000000000000000UL});
		public static readonly BitSet _UNION_in_subQuery3480 = new BitSet(new ulong[]{0x29000000000000UL,0x42400800000000UL,0x4UL});
		public static readonly BitSet _innerSubQuery_in_subQuery3483 = new BitSet(new ulong[]{0x2UL,0x1000000000000000UL});
		public static readonly BitSet _queryRule_in_innerSubQuery3497 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_path3585 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _DOT_in_path3589 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_path3594 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _IDENT_in_identifier3610 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  NHibernate.Hql.Ast.ANTLR 
